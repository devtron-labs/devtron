// Code generated by mockery v2.32.0. DO NOT EDIT.

package mocks

import (
	chart "github.com/devtron-labs/devtron/pkg/chart"
	bean "github.com/devtron-labs/devtron/pkg/deployment/manifest/deploymentTemplate/chartRef/bean"

	context "context"

	json "encoding/json"

	mock "github.com/stretchr/testify/mock"
)

// ChartService is an autogenerated mock type for the ChartService type
type ChartService struct {
	mock.Mock
}

// ChartRefAutocompleteForAppOrEnv provides a mock function with given fields: appId, envId
func (_m *ChartService) ChartRefAutocompleteForAppOrEnv(appId int, envId int) (*bean.ChartRefAutocompleteResponse, error) {
	ret := _m.Called(appId, envId)

	var r0 *bean.ChartRefAutocompleteResponse
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int) (*bean.ChartRefAutocompleteResponse, error)); ok {
		return rf(appId, envId)
	}
	if rf, ok := ret.Get(0).(func(int, int) *bean.ChartRefAutocompleteResponse); ok {
		r0 = rf(appId, envId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*bean.ChartRefAutocompleteResponse)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(appId, envId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CheckIfChartRefUserUploadedByAppId provides a mock function with given fields: id
func (_m *ChartService) CheckIfChartRefUserUploadedByAppId(id int) (bool, error) {
	ret := _m.Called(id)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (bool, error)); ok {
		return rf(id)
	}
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(id)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(id)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Create provides a mock function with given fields: templateRequest, ctx
func (_m *ChartService) Create(templateRequest chart.TemplateRequest, ctx context.Context) (*chart.TemplateRequest, error) {
	ret := _m.Called(templateRequest, ctx)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(chart.TemplateRequest, context.Context) (*chart.TemplateRequest, error)); ok {
		return rf(templateRequest, ctx)
	}
	if rf, ok := ret.Get(0).(func(chart.TemplateRequest, context.Context) *chart.TemplateRequest); ok {
		r0 = rf(templateRequest, ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(chart.TemplateRequest, context.Context) error); ok {
		r1 = rf(templateRequest, ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// CreateChartFromEnvOverride provides a mock function with given fields: templateRequest, ctx
func (_m *ChartService) CreateChartFromEnvOverride(templateRequest chart.TemplateRequest, ctx context.Context) (*chart.TemplateRequest, error) {
	ret := _m.Called(templateRequest, ctx)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(chart.TemplateRequest, context.Context) (*chart.TemplateRequest, error)); ok {
		return rf(templateRequest, ctx)
	}
	if rf, ok := ret.Get(0).(func(chart.TemplateRequest, context.Context) *chart.TemplateRequest); ok {
		r0 = rf(templateRequest, ctx)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(chart.TemplateRequest, context.Context) error); ok {
		r1 = rf(templateRequest, ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindLatestChartForAppByAppId provides a mock function with given fields: appId
func (_m *ChartService) FindLatestChartForAppByAppId(appId int) (*chart.TemplateRequest, error) {
	ret := _m.Called(appId)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (*chart.TemplateRequest, error)); ok {
		return rf(appId)
	}
	if rf, ok := ret.Get(0).(func(int) *chart.TemplateRequest); ok {
		r0 = rf(appId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(appId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// FindPreviousChartByAppId provides a mock function with given fields: appId
func (_m *ChartService) FindPreviousChartByAppId(appId int) (*chart.TemplateRequest, error) {
	ret := _m.Called(appId)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (*chart.TemplateRequest, error)); ok {
		return rf(appId)
	}
	if rf, ok := ret.Get(0).(func(int) *chart.TemplateRequest); ok {
		r0 = rf(appId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(appId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// GetByAppIdAndChartRefId provides a mock function with given fields: appId, chartRefId
func (_m *ChartService) GetByAppIdAndChartRefId(appId int, chartRefId int) (*chart.TemplateRequest, error) {
	ret := _m.Called(appId, chartRefId)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int) (*chart.TemplateRequest, error)); ok {
		return rf(appId, chartRefId)
	}
	if rf, ok := ret.Get(0).(func(int, int) *chart.TemplateRequest); ok {
		r0 = rf(appId, chartRefId)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(int, int) error); ok {
		r1 = rf(appId, chartRefId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsGitOpsRepoAlreadyRegistered provides a mock function with given fields: gitOpsRepoUrl
func (_m *ChartService) IsGitOpsRepoAlreadyRegistered(gitOpsRepoUrl string) (bool, error) {
	ret := _m.Called(gitOpsRepoUrl)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(string) (bool, error)); ok {
		return rf(gitOpsRepoUrl)
	}
	if rf, ok := ret.Get(0).(func(string) bool); ok {
		r0 = rf(gitOpsRepoUrl)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(gitOpsRepoUrl)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsGitOpsRepoConfiguredForDevtronApps provides a mock function with given fields: appId
func (_m *ChartService) IsGitOpsRepoConfiguredForDevtronApps(appId int) (bool, error) {
	ret := _m.Called(appId)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int) (bool, error)); ok {
		return rf(appId)
	}
	if rf, ok := ret.Get(0).(func(int) bool); ok {
		r0 = rf(appId)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int) error); ok {
		r1 = rf(appId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// IsReadyToTrigger provides a mock function with given fields: appId, envId, pipelineId
func (_m *ChartService) IsReadyToTrigger(appId int, envId int, pipelineId int) (chart.IsReady, error) {
	ret := _m.Called(appId, envId, pipelineId)

	var r0 chart.IsReady
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, int) (chart.IsReady, error)); ok {
		return rf(appId, envId, pipelineId)
	}
	if rf, ok := ret.Get(0).(func(int, int, int) chart.IsReady); ok {
		r0 = rf(appId, envId, pipelineId)
	} else {
		r0 = ret.Get(0).(chart.IsReady)
	}

	if rf, ok := ret.Get(1).(func(int, int, int) error); ok {
		r1 = rf(appId, envId, pipelineId)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// PatchEnvOverrides provides a mock function with given fields: values, oldChartType, newChartType
func (_m *ChartService) PatchEnvOverrides(values json.RawMessage, oldChartType string, newChartType string) (json.RawMessage, error) {
	ret := _m.Called(values, oldChartType, newChartType)

	var r0 json.RawMessage
	var r1 error
	if rf, ok := ret.Get(0).(func(json.RawMessage, string, string) (json.RawMessage, error)); ok {
		return rf(values, oldChartType, newChartType)
	}
	if rf, ok := ret.Get(0).(func(json.RawMessage, string, string) json.RawMessage); ok {
		r0 = rf(values, oldChartType, newChartType)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(json.RawMessage)
		}
	}

	if rf, ok := ret.Get(1).(func(json.RawMessage, string, string) error); ok {
		r1 = rf(values, oldChartType, newChartType)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// UpdateAppOverride provides a mock function with given fields: ctx, templateRequest
func (_m *ChartService) UpdateAppOverride(ctx context.Context, templateRequest *chart.TemplateRequest) (*chart.TemplateRequest, error) {
	ret := _m.Called(ctx, templateRequest)

	var r0 *chart.TemplateRequest
	var r1 error
	if rf, ok := ret.Get(0).(func(context.Context, *chart.TemplateRequest) (*chart.TemplateRequest, error)); ok {
		return rf(ctx, templateRequest)
	}
	if rf, ok := ret.Get(0).(func(context.Context, *chart.TemplateRequest) *chart.TemplateRequest); ok {
		r0 = rf(ctx, templateRequest)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(*chart.TemplateRequest)
		}
	}

	if rf, ok := ret.Get(1).(func(context.Context, *chart.TemplateRequest) error); ok {
		r1 = rf(ctx, templateRequest)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ConfigureGitOpsRepoUrl provides a mock function with given fields: appId, repoUrl, chartLocation, userId
func (_m *ChartService) ConfigureGitOpsRepoUrl(appId int, repoUrl string, chartLocation string, userId int32) error {
	ret := _m.Called(appId, repoUrl, chartLocation, userId)

	var r0 error
	if rf, ok := ret.Get(0).(func(int, string, string, int32) error); ok {
		r0 = rf(appId, repoUrl, chartLocation, userId)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// UpgradeForApp provides a mock function with given fields: appId, chartRefId, newAppOverride, userId, ctx
func (_m *ChartService) UpgradeForApp(appId int, chartRefId int, newAppOverride map[string]interface{}, userId int32, ctx context.Context) (bool, error) {
	ret := _m.Called(appId, chartRefId, newAppOverride, userId, ctx)

	var r0 bool
	var r1 error
	if rf, ok := ret.Get(0).(func(int, int, map[string]interface{}, int32, context.Context) (bool, error)); ok {
		return rf(appId, chartRefId, newAppOverride, userId, ctx)
	}
	if rf, ok := ret.Get(0).(func(int, int, map[string]interface{}, int32, context.Context) bool); ok {
		r0 = rf(appId, chartRefId, newAppOverride, userId, ctx)
	} else {
		r0 = ret.Get(0).(bool)
	}

	if rf, ok := ret.Get(1).(func(int, int, map[string]interface{}, int32, context.Context) error); ok {
		r1 = rf(appId, chartRefId, newAppOverride, userId, ctx)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// NewChartService creates a new instance of ChartService. It also registers a testing interface on the mock and a cleanup function to assert the mocks expectations.
// The first argument is typically a *testing.T value.
func NewChartService(t interface {
	mock.TestingT
	Cleanup(func())
}) *ChartService {
	mock := &ChartService{}
	mock.Mock.Test(t)

	t.Cleanup(func() { mock.AssertExpectations(t) })

	return mock
}
