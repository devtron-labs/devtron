# Visual Diagrams for Go Concurrency at Scale Talk

## 1. Worker Pool Pattern

### Sequential Processing (BAD)
```
Time â†’

Item 1: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100ms
Item 2:             [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100ms
Item 3:                         [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100ms
Item 4:                                     [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100ms
Item 5:                                                 [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 100ms

Total: 500ms
```

### Unlimited Goroutines (BAD)
```
Time â†’

Item 1: [â–ˆâ–ˆâ–ˆâ–ˆ]
Item 2: [â–ˆâ–ˆâ–ˆâ–ˆ]
Item 3: [â–ˆâ–ˆâ–ˆâ–ˆ]
Item 4: [â–ˆâ–ˆâ–ˆâ–ˆ]
Item 5: [â–ˆâ–ˆâ–ˆâ–ˆ]
...
Item 1000: [â–ˆâ–ˆâ–ˆâ–ˆ]

Total: 100ms but ğŸ’¥ CRASH (too many goroutines!)
```

### Worker Pool (GOOD)
```
Time â†’

Batch 1 (size=3):
  Item 1: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
  Item 2: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
  Item 3: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
          â†“ Wait for batch
Batch 2 (size=2):
  Item 4:             [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]
  Item 5:             [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ]

Total: 200ms âœ… Controlled concurrency
```

---

## 2. Fan-Out/Fan-In Pattern

### Diagram
```
                    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                    â”‚   Request   â”‚
                    â”‚  (Handler)  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”
                    â”‚  WaitGroup  â”‚
                    â”‚   wg.Add(3) â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                 â”‚                 â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”       â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”      â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ Fetch   â”‚       â”‚ Fetch   â”‚      â”‚ Fetch   â”‚
    â”‚   CI    â”‚       â”‚   CD    â”‚      â”‚  User   â”‚
    â”‚ Status  â”‚       â”‚ Status  â”‚      â”‚  Data   â”‚
    â”‚ (200ms) â”‚       â”‚ (300ms) â”‚      â”‚ (150ms) â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜       â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜      â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚                 â”‚                 â”‚
         â”‚    wg.Done()    â”‚    wg.Done()    â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚  wg.Wait()  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚   Combine   â”‚
                    â”‚   Results   â”‚
                    â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                           â”‚
                    â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”
                    â”‚   Response  â”‚
                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Sequential: 200 + 300 + 150 = 650ms
Parallel:   max(200, 300, 150) = 300ms âœ… 2.2x faster!
```

---

## 3. Rate Limiting with Batching

### Without Rate Limiting
```
Database Connection Pool (max 10 connections)

Request: Check 1000 permissions
         â†“
    [Spawn 1000 goroutines]
         â†“
    ğŸ’¥ Connection pool exhausted!
    ğŸ’¥ Queries timeout
    ğŸ’¥ System crash
```

### With Rate Limiting (Batching)
```
Database Connection Pool (max 10 connections)

Request: Check 1000 permissions
         â†“
    [Batch 1: 10 workers] â†’ [100 items] âœ…
         â†“ wg.Wait()
    [Batch 2: 10 workers] â†’ [100 items] âœ…
         â†“ wg.Wait()
    [Batch 3: 10 workers] â†’ [100 items] âœ…
         â†“ wg.Wait()
    ... (10 batches total)
         â†“
    âœ… All 1000 checked in 1.5s
    âœ… Max 10 concurrent connections
    âœ… System stable
```

---

## 4. Context Cancellation Flow

### HTTP Request with Cancellation
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   Browser    â”‚
â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜
       â”‚ HTTP Request
       â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         HTTP Handler             â”‚
â”‚                                  â”‚
â”‚  ctx, cancel := context.         â”‚
â”‚    WithCancel(r.Context())       â”‚
â”‚                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Goroutine: Watch for      â”‚ â”‚
â”‚  â”‚  client disconnect         â”‚ â”‚
â”‚  â”‚                            â”‚ â”‚
â”‚  â”‚  select {                  â”‚ â”‚
â”‚  â”‚    case <-done:            â”‚ â”‚
â”‚  â”‚    case <-closed:          â”‚ â”‚
â”‚  â”‚      cancel() â† Trigger!   â”‚ â”‚
â”‚  â”‚  }                         â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚                                  â”‚
â”‚  service.Process(ctx, data)      â”‚
â”‚         â”‚                        â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚
          â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚      Service Layer               â”‚
â”‚                                  â”‚
â”‚  for _, item := range items {    â”‚
â”‚    select {                      â”‚
â”‚      case <-ctx.Done():          â”‚
â”‚        return â† Exit early! âœ…   â”‚
â”‚      default:                    â”‚
â”‚        process(item)             â”‚
â”‚    }                             â”‚
â”‚  }                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

User closes browser â†’ Context cancelled â†’ Work stops âœ…
```

---

## 5. SSE Broker Pattern

### Architecture
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    SSE Broker                       â”‚
â”‚                                                     â”‚
â”‚  Channels:                                          â”‚
â”‚    â€¢ notifier    chan SSEMessage                    â”‚
â”‚    â€¢ register    chan *Connection                   â”‚
â”‚    â€¢ unregister  chan *Connection                   â”‚
â”‚    â€¢ shutdown    chan bool                          â”‚
â”‚                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  Main Loop (select statement)                 â”‚ â”‚
â”‚  â”‚                                               â”‚ â”‚
â”‚  â”‚  for {                                        â”‚ â”‚
â”‚  â”‚    select {                                   â”‚ â”‚
â”‚  â”‚      case <-shutdown:                         â”‚ â”‚
â”‚  â”‚        // Close all connections               â”‚ â”‚
â”‚  â”‚      case conn := <-register:                 â”‚ â”‚
â”‚  â”‚        // Add new client                      â”‚ â”‚
â”‚  â”‚      case conn := <-unregister:               â”‚ â”‚
â”‚  â”‚        // Remove client                       â”‚ â”‚
â”‚  â”‚      case msg := <-notifier:                  â”‚ â”‚
â”‚  â”‚        // Broadcast to all clients            â”‚ â”‚
â”‚  â”‚    }                                          â”‚ â”‚
â”‚  â”‚  }                                            â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚              â”‚              â”‚
         â–¼              â–¼              â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚Client 1â”‚    â”‚Client 2â”‚    â”‚Client 3â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Non-Blocking Broadcast
```
Broker receives message
    â”‚
    â–¼
For each client:
    â”‚
    â”œâ”€â†’ select {
    â”‚     case client.ch <- msg:
    â”‚       âœ… Sent successfully
    â”‚     default:
    â”‚       âŒ Channel full â†’ Disconnect slow client
    â”‚   }
    â”‚
    â””â”€â†’ Next client

Result: Fast clients not blocked by slow clients âœ…
```

---

## 6. Thread-Safe Result Collection

### Using sync.Map
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Main Goroutine                  â”‚
â”‚                                         â”‚
â”‚  resultMap := &sync.Map{}               â”‚
â”‚  var wg sync.WaitGroup                  â”‚
â”‚                                         â”‚
â”‚  for _, cluster := range clusters {     â”‚
â”‚    wg.Add(1)                            â”‚
â”‚    go worker(cluster, resultMap, &wg)   â”‚
â”‚  }                                      â”‚
â”‚                                         â”‚
â”‚  wg.Wait()                              â”‚
â”‚  // All results in resultMap âœ…         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚         â”‚         â”‚
         â–¼         â–¼         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚Worker 1â”‚ â”‚Worker 2â”‚ â”‚Worker 3â”‚
    â”‚        â”‚ â”‚        â”‚ â”‚        â”‚
    â”‚ result â”‚ â”‚ result â”‚ â”‚ result â”‚
    â”‚   â”‚    â”‚ â”‚   â”‚    â”‚ â”‚   â”‚    â”‚
    â”‚   â–¼    â”‚ â”‚   â–¼    â”‚ â”‚   â–¼    â”‚
    â”‚ Store()â”‚ â”‚ Store()â”‚ â”‚ Store()â”‚
    â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
        â”‚          â”‚          â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚     sync.Map         â”‚
        â”‚  (Thread-safe!)      â”‚
        â”‚                      â”‚
        â”‚  cluster1 â†’ result1  â”‚
        â”‚  cluster2 â†’ result2  â”‚
        â”‚  cluster3 â†’ result3  â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## 7. Atomic Counters

### Without Atomic (RACE CONDITION!)
```
var counter int = 0

Goroutine 1:          Goroutine 2:
  Read: 0               Read: 0
  Add: 0 + 1 = 1        Add: 0 + 1 = 1
  Write: 1              Write: 1

Result: counter = 1 âŒ (should be 2!)
```

### With Atomic (CORRECT!)
```
var counter uint64 = 0

Goroutine 1:                    Goroutine 2:
  atomic.AddUint64(&counter, 1)   atomic.AddUint64(&counter, 1)
         â†“                                 â†“
    [Atomic operation]              [Atomic operation]
         â†“                                 â†“
  Result: counter = 2 âœ…

Atomic operations are:
  â€¢ Thread-safe
  â€¢ Lock-free
  â€¢ Fast
```

---

## 8. Devtron Case Study: Hibernation Check

### Flow Diagram
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Check if 100 K8s resources can be hibernated    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Filter replica nodes  â”‚
        â”‚  (Deployments, etc.)   â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Batch processing      â”‚
        â”‚  batchSize = 10        â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â–¼â”€â”€â”€â”€â”
    â”‚ Batch 1 â”‚             â”‚ Batch 2 â”‚
    â”‚ (10)    â”‚             â”‚ (10)    â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚                       â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â”€â”
    â”‚ Worker  â”‚             â”‚ Worker  â”‚
    â”‚ Pool    â”‚             â”‚ Pool    â”‚
    â”‚         â”‚             â”‚         â”‚
    â”‚ â”Œâ”€â”€â”€â”€â”€â” â”‚             â”‚ â”Œâ”€â”€â”€â”€â”€â” â”‚
    â”‚ â”‚ W1  â”‚ â”‚             â”‚ â”‚ W1  â”‚ â”‚
    â”‚ â”‚ W2  â”‚ â”‚             â”‚ â”‚ W2  â”‚ â”‚
    â”‚ â”‚ ... â”‚ â”‚             â”‚ â”‚ ... â”‚ â”‚
    â”‚ â”‚ W10 â”‚ â”‚             â”‚ â”‚ W10 â”‚ â”‚
    â”‚ â””â”€â”€â”¬â”€â”€â”˜ â”‚             â”‚ â””â”€â”€â”¬â”€â”€â”˜ â”‚
    â”‚    â”‚    â”‚             â”‚    â”‚    â”‚
    â”‚    â–¼    â”‚             â”‚    â–¼    â”‚
    â”‚ atomic. â”‚             â”‚ atomic. â”‚
    â”‚ AddUint â”‚             â”‚ AddUint â”‚
    â”‚ 64()    â”‚             â”‚ 64()    â”‚
    â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”˜
         â”‚                       â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                     â”‚
                     â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚  Aggregate results     â”‚
        â”‚                        â”‚
        â”‚  canBeHibernated: 85   â”‚
        â”‚  hibernated: 42        â”‚
        â”‚                        â”‚
        â”‚  Status: Partially     â”‚
        â”‚  Hibernated            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Performance:
  Sequential: 100 Ã— 50ms = 5000ms
  Parallel (batch=10): ~500ms âœ… 10x faster!
```

---

## 9. Comparison: Sequential vs Concurrent vs Worker Pool

### Processing 100 Items (50ms each)

#### Sequential
```
Time: 0ms                                    5000ms
      |â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”|
      [Item 1][Item 2][Item 3]...[Item 100]

Total: 5000ms
Goroutines: 1
Memory: Low
```

#### Unlimited Concurrent
```
Time: 0ms    50ms
      |â”â”â”â”â”â”|
      [Item 1]
      [Item 2]
      [Item 3]
      ...
      [Item 100]

Total: 50ms âœ… Fast
Goroutines: 100 âŒ High
Memory: High âŒ
Risk: Resource exhaustion âŒ
```

#### Worker Pool (batch=10)
```
Time: 0ms   50ms  100ms 150ms 200ms 250ms 300ms 350ms 400ms 450ms 500ms
      |â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|
Batch 1: [1-10]
Batch 2:      [11-20]
Batch 3:            [21-30]
...
Batch 10:                                                    [91-100]

Total: 500ms âœ… Good
Goroutines: 10 âœ… Controlled
Memory: Low âœ…
Risk: None âœ…
```

---

## 10. Error Handling Patterns

### Pattern 1: Error Channel
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Main Goroutine              â”‚
â”‚                                     â”‚
â”‚  errChan := make(chan error, 100)   â”‚
â”‚                                     â”‚
â”‚  for _, item := range items {       â”‚
â”‚    go worker(item, errChan)         â”‚
â”‚  }                                  â”‚
â”‚                                     â”‚
â”‚  for i := 0; i < len(items); i++ {  â”‚
â”‚    if err := <-errChan; err != nil {â”‚
â”‚      log.Error(err)                 â”‚
â”‚    }                                â”‚
â”‚  }                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²         â–²         â–²
         â”‚         â”‚         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â” â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚Worker 1â”‚ â”‚Worker 2â”‚ â”‚Worker 3â”‚
    â”‚        â”‚ â”‚        â”‚ â”‚        â”‚
    â”‚ if err â”‚ â”‚ if err â”‚ â”‚ if err â”‚
    â”‚   â†“    â”‚ â”‚   â†“    â”‚ â”‚   â†“    â”‚
    â”‚ errChanâ”‚ â”‚ errChanâ”‚ â”‚ errChanâ”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Pattern 2: errgroup
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚         Main Goroutine              â”‚
â”‚                                     â”‚
â”‚  g, ctx := errgroup.WithContext(ctx)â”‚
â”‚                                     â”‚
â”‚  for _, item := range items {       â”‚
â”‚    item := item                     â”‚
â”‚    g.Go(func() error {              â”‚
â”‚      return worker(ctx, item)       â”‚
â”‚    })                               â”‚
â”‚  }                                  â”‚
â”‚                                     â”‚
â”‚  if err := g.Wait(); err != nil {   â”‚
â”‚    return err  â† First error        â”‚
â”‚  }                                  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â–²         â–²         â–²
         â”‚         â”‚         â”‚
    â”Œâ”€â”€â”€â”€â”´â”€â”€â”€â” â”Œâ”€â”€â”€â”´â”€â”€â”€â”€â” â”Œâ”€â”´â”€â”€â”€â”€â”€â”€â”
    â”‚Worker 1â”‚ â”‚Worker 2â”‚ â”‚Worker 3â”‚
    â”‚   âœ…   â”‚ â”‚   âŒ   â”‚ â”‚   âœ…   â”‚
    â”‚  nil   â”‚ â”‚  error â”‚ â”‚  nil   â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚
                   â””â”€â†’ Returned immediately
                       Other workers cancelled via ctx
```

---

## 11. Memory Layout: Goroutines vs Threads

### OS Threads
```
Thread 1: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 2MB stack
Thread 2: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 2MB stack
Thread 3: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 2MB stack
...
Thread 100: [â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ] 2MB stack

Total: 200MB for 100 threads âŒ
```

### Goroutines
```
Goroutine 1: [â–ˆâ–ˆ] 2KB stack (grows as needed)
Goroutine 2: [â–ˆâ–ˆ] 2KB stack
Goroutine 3: [â–ˆâ–ˆ] 2KB stack
...
Goroutine 100: [â–ˆâ–ˆ] 2KB stack

Total: 200KB for 100 goroutines âœ…
Can easily run 10,000+ goroutines!
```

---

## 12. Timeline: Real Production Scenario

### Scenario: Deploy to 50 Kubernetes Clusters

#### Before Optimization (Sequential)
```
Time: 0s    10s   20s   30s   40s   50s   60s   70s   80s   90s   100s
      |â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|
      [C1][C2][C3][C4][C5]...[C50]

Total: 100s (1m 40s) âŒ
User experience: Poor
```

#### After Optimization (Worker Pool, batch=10)
```
Time: 0s    2s    4s    6s    8s    10s
      |â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|â”â”â”â”â”|
Batch 1: [C1-C10]
Batch 2:      [C11-C20]
Batch 3:            [C21-C30]
Batch 4:                  [C31-C40]
Batch 5:                        [C41-C50]

Total: 10s âœ…
User experience: Excellent
Improvement: 10x faster!
```

---

These diagrams can be:
1. **Drawn on whiteboard** during the talk
2. **Included in slides** as images
3. **Used in documentation**
4. **Shared as ASCII art** in blog posts

The visual representation helps the audience understand complex concurrent patterns much better than code alone!

