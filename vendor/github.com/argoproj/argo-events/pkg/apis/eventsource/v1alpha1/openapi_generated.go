//go:build !ignore_autogenerated
// +build !ignore_autogenerated

/*
Copyright 2021 BlackRock, Inc.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

// Code generated by openapi-gen. DO NOT EDIT.

// This file was autogenerated by openapi-gen. Do not edit it manually!

package v1alpha1

import (
	common "k8s.io/kube-openapi/pkg/common"
	spec "k8s.io/kube-openapi/pkg/validation/spec"
)

func GetOpenAPIDefinitions(ref common.ReferenceCallback) map[string]common.OpenAPIDefinition {
	return map[string]common.OpenAPIDefinition{
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPConsumeConfig":          schema_pkg_apis_eventsource_v1alpha1_AMQPConsumeConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource":            schema_pkg_apis_eventsource_v1alpha1_AMQPEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPExchangeDeclareConfig":  schema_pkg_apis_eventsource_v1alpha1_AMQPExchangeDeclareConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueBindConfig":        schema_pkg_apis_eventsource_v1alpha1_AMQPQueueBindConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueDeclareConfig":     schema_pkg_apis_eventsource_v1alpha1_AMQPQueueDeclareConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AzureEventsHubEventSource":  schema_pkg_apis_eventsource_v1alpha1_AzureEventsHubEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketAuth":              schema_pkg_apis_eventsource_v1alpha1_BitbucketAuth(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketBasicAuth":         schema_pkg_apis_eventsource_v1alpha1_BitbucketBasicAuth(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketEventSource":       schema_pkg_apis_eventsource_v1alpha1_BitbucketEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketRepository":        schema_pkg_apis_eventsource_v1alpha1_BitbucketRepository(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerEventSource": schema_pkg_apis_eventsource_v1alpha1_BitbucketServerEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerRepository":  schema_pkg_apis_eventsource_v1alpha1_BitbucketServerRepository(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource":        schema_pkg_apis_eventsource_v1alpha1_CalendarEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CatchupConfiguration":       schema_pkg_apis_eventsource_v1alpha1_CatchupConfiguration(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ConfigMapPersistence":       schema_pkg_apis_eventsource_v1alpha1_ConfigMapPersistence(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EmitterEventSource":         schema_pkg_apis_eventsource_v1alpha1_EmitterEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventPersistence":           schema_pkg_apis_eventsource_v1alpha1_EventPersistence(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSource":                schema_pkg_apis_eventsource_v1alpha1_EventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter":          schema_pkg_apis_eventsource_v1alpha1_EventSourceFilter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceList":            schema_pkg_apis_eventsource_v1alpha1_EventSourceList(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceSpec":            schema_pkg_apis_eventsource_v1alpha1_EventSourceSpec(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceStatus":          schema_pkg_apis_eventsource_v1alpha1_EventSourceStatus(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource":            schema_pkg_apis_eventsource_v1alpha1_FileEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GenericEventSource":         schema_pkg_apis_eventsource_v1alpha1_GenericEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubAppCreds":             schema_pkg_apis_eventsource_v1alpha1_GithubAppCreds(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource":          schema_pkg_apis_eventsource_v1alpha1_GithubEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource":          schema_pkg_apis_eventsource_v1alpha1_GitlabEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource":            schema_pkg_apis_eventsource_v1alpha1_HDFSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaConsumerGroup":         schema_pkg_apis_eventsource_v1alpha1_KafkaConsumerGroup(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource":           schema_pkg_apis_eventsource_v1alpha1_KafkaEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource":            schema_pkg_apis_eventsource_v1alpha1_MQTTEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSAuth":                   schema_pkg_apis_eventsource_v1alpha1_NATSAuth(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventsSource":           schema_pkg_apis_eventsource_v1alpha1_NATSEventsSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NSQEventSource":             schema_pkg_apis_eventsource_v1alpha1_NSQEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.OwnedRepositories":          schema_pkg_apis_eventsource_v1alpha1_OwnedRepositories(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource":          schema_pkg_apis_eventsource_v1alpha1_PubSubEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PulsarEventSource":          schema_pkg_apis_eventsource_v1alpha1_PulsarEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisEventSource":           schema_pkg_apis_eventsource_v1alpha1_RedisEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisStreamEventSource":     schema_pkg_apis_eventsource_v1alpha1_RedisStreamEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource":        schema_pkg_apis_eventsource_v1alpha1_ResourceEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter":             schema_pkg_apis_eventsource_v1alpha1_ResourceFilter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource":             schema_pkg_apis_eventsource_v1alpha1_SNSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource":             schema_pkg_apis_eventsource_v1alpha1_SQSEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Selector":                   schema_pkg_apis_eventsource_v1alpha1_Selector(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Service":                    schema_pkg_apis_eventsource_v1alpha1_Service(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource":           schema_pkg_apis_eventsource_v1alpha1_SlackEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource":     schema_pkg_apis_eventsource_v1alpha1_StorageGridEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridFilter":          schema_pkg_apis_eventsource_v1alpha1_StorageGridFilter(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StripeEventSource":          schema_pkg_apis_eventsource_v1alpha1_StripeEventSource(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Template":                   schema_pkg_apis_eventsource_v1alpha1_Template(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WatchPathConfig":            schema_pkg_apis_eventsource_v1alpha1_WatchPathConfig(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext":             schema_pkg_apis_eventsource_v1alpha1_WebhookContext(ref),
		"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource":         schema_pkg_apis_eventsource_v1alpha1_WebhookEventSource(ref),
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPConsumeConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPConsumeConfig holds the configuration to immediately starts delivering queued messages",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"consumerTag": {
						SchemaProps: spec.SchemaProps{
							Description: "ConsumerTag is the identity of the consumer included in every delivery",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"autoAck": {
						SchemaProps: spec.SchemaProps{
							Description: "AutoAck when true, the server will acknowledge deliveries to this consumer prior to writing the delivery to the network",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"exclusive": {
						SchemaProps: spec.SchemaProps{
							Description: "Exclusive when true, the server will ensure that this is the sole consumer from this queue",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noLocal": {
						SchemaProps: spec.SchemaProps{
							Description: "NoLocal flag is not supported by RabbitMQ",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noWait": {
						SchemaProps: spec.SchemaProps{
							Description: "NowWait when true, do not wait for the server to confirm the request and immediately begin deliveries",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPEventSource refers to an event-source for AMQP stream events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL for rabbitmq service",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exchangeName": {
						SchemaProps: spec.SchemaProps{
							Description: "ExchangeName is the exchange name For more information, visit https://www.rabbitmq.com/tutorials/amqp-concepts.html",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exchangeType": {
						SchemaProps: spec.SchemaProps{
							Description: "ExchangeType is rabbitmq exchange type",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"routingKey": {
						SchemaProps: spec.SchemaProps{
							Description: "Routing key for bindings",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the amqp client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"exchangeDeclare": {
						SchemaProps: spec.SchemaProps{
							Description: "ExchangeDeclare holds the configuration for the exchange on the server For more information, visit https://pkg.go.dev/github.com/rabbitmq/amqp091-go#Channel.ExchangeDeclare",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPExchangeDeclareConfig"),
						},
					},
					"queueDeclare": {
						SchemaProps: spec.SchemaProps{
							Description: "QueueDeclare holds the configuration of a queue to hold messages and deliver to consumers. Declaring creates a queue if it doesn't already exist, or ensures that an existing queue matches the same parameters For more information, visit https://pkg.go.dev/github.com/rabbitmq/amqp091-go#Channel.QueueDeclare",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueDeclareConfig"),
						},
					},
					"queueBind": {
						SchemaProps: spec.SchemaProps{
							Description: "QueueBind holds the configuration that binds an exchange to a queue so that publishings to the exchange will be routed to the queue when the publishing routing key matches the binding routing key For more information, visit https://pkg.go.dev/github.com/rabbitmq/amqp091-go#Channel.QueueBind",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueBindConfig"),
						},
					},
					"consume": {
						SchemaProps: spec.SchemaProps{
							Description: "Consume holds the configuration to immediately starts delivering queued messages For more information, visit https://pkg.go.dev/github.com/rabbitmq/amqp091-go#Channel.Consume",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPConsumeConfig"),
						},
					},
					"auth": {
						SchemaProps: spec.SchemaProps{
							Description: "Auth hosts secret selectors for username and password",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.BasicAuth"),
						},
					},
					"urlSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "URLSecret is secret reference for rabbitmq service URL",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"exchangeName", "exchangeType", "routingKey"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.BasicAuth", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPConsumeConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPExchangeDeclareConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueBindConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPQueueDeclareConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPExchangeDeclareConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPExchangeDeclareConfig holds the configuration for the exchange on the server",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"durable": {
						SchemaProps: spec.SchemaProps{
							Description: "Durable keeps the exchange also after the server restarts",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"autoDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "AutoDelete removes the exchange when no bindings are active",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"internal": {
						SchemaProps: spec.SchemaProps{
							Description: "Internal when true does not accept publishings",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noWait": {
						SchemaProps: spec.SchemaProps{
							Description: "NowWait when true does not wait for a confirmation from the server",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPQueueBindConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPQueueBindConfig holds the configuration that binds an exchange to a queue so that publishings to the exchange will be routed to the queue when the publishing routing key matches the binding routing key",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"noWait": {
						SchemaProps: spec.SchemaProps{
							Description: "NowWait false and the queue could not be bound, the channel will be closed with an error",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AMQPQueueDeclareConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AMQPQueueDeclareConfig holds the configuration of a queue to hold messages and deliver to consumers. Declaring creates a queue if it doesn't already exist, or ensures that an existing queue matches the same parameters",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the queue. If empty the server auto-generates a unique name for this queue",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"durable": {
						SchemaProps: spec.SchemaProps{
							Description: "Durable keeps the queue also after the server restarts",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"autoDelete": {
						SchemaProps: spec.SchemaProps{
							Description: "AutoDelete removes the queue when no consumers are active",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"exclusive": {
						SchemaProps: spec.SchemaProps{
							Description: "Exclusive sets the queues to be accessible only by the connection that declares them and will be deleted wgen the connection closes",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"noWait": {
						SchemaProps: spec.SchemaProps{
							Description: "NowWait when true, the queue assumes to be declared on the server",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"arguments": {
						SchemaProps: spec.SchemaProps{
							Description: "Arguments of a queue (also known as \"x-arguments\") used for optional features and plugins",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_AzureEventsHubEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "AzureEventsHubEventSource describes the event source for azure events hub More info at https://docs.microsoft.com/en-us/azure/event-hubs/",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"fqdn": {
						SchemaProps: spec.SchemaProps{
							Description: "FQDN of the EventHubs namespace you created More info at https://docs.microsoft.com/en-us/azure/event-hubs/event-hubs-get-connection-string",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"sharedAccessKeyName": {
						SchemaProps: spec.SchemaProps{
							Description: "SharedAccessKeyName is the name you chose for your application's SAS keys",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"sharedAccessKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SharedAccessKey is the generated value of the key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"hubName": {
						SchemaProps: spec.SchemaProps{
							Description: "Event Hub path/name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"fqdn", "hubName"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketAuth(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BitbucketAuth holds the different auth strategies for connecting to Bitbucket",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"basic": {
						SchemaProps: spec.SchemaProps{
							Description: "Basic is BasicAuth auth strategy.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketBasicAuth"),
						},
					},
					"oauthToken": {
						SchemaProps: spec.SchemaProps{
							Description: "OAuthToken refers to the K8s secret that holds the OAuth Bearer token.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketBasicAuth", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketBasicAuth(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BasicAuth holds the information required to authenticate user via basic auth mechanism",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username refers to the K8s secret that holds the username.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password refers to the K8s secret that holds the password.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
				},
				Required: []string{"username", "password"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BitbucketEventSource describes the event source for Bitbucket",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"deleteHookOnFinish": {
						SchemaProps: spec.SchemaProps{
							Description: "DeleteHookOnFinish determines whether to delete the defined Bitbucket hook once the event source is stopped.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will be passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook refers to the configuration required to run an http server",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"auth": {
						SchemaProps: spec.SchemaProps{
							Description: "Auth information required to connect to Bitbucket.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketAuth"),
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Events this webhook is subscribed to.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"owner": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedOwner is the owner of the repository. Deprecated: use Repositories instead. Will be unsupported in v1.9",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"projectKey": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedProjectKey is the key of the project to which the repository relates Deprecated: use Repositories instead. Will be unsupported in v1.9",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositorySlug": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRepositorySlug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL Deprecated: use Repositories instead. Will be unsupported in v1.9",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositories": {
						SchemaProps: spec.SchemaProps{
							Description: "Repositories holds a list of repositories for which integration needs to set up",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketRepository"),
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"webhook", "auth", "events"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketAuth", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketRepository", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketRepository(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"owner": {
						SchemaProps: spec.SchemaProps{
							Description: "Owner is the owner of the repository",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositorySlug": {
						SchemaProps: spec.SchemaProps{
							Description: "RepositorySlug is a URL-friendly version of a repository name, automatically generated by Bitbucket for use in the URL",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"owner", "repositorySlug"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketServerEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "BitbucketServerEventSource refers to event-source related to Bitbucket Server events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook holds configuration to run a http server",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"projectKey": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedProjectKey is the key of project for which integration needs to set up Deprecated: use Repositories instead. Will be unsupported in v1.8",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositorySlug": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRepositorySlug is the slug of the repository for which integration needs to set up Deprecated: use Repositories instead. Will be unsupported in v1.8",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositories": {
						SchemaProps: spec.SchemaProps{
							Description: "Repositories holds a list of repositories for which integration needs to set up",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerRepository"),
									},
								},
							},
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Events are bitbucket event to listen to. Refer https://confluence.atlassian.com/bitbucketserver/event-payload-938025882.html",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"accessToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessToken is reference to K8s secret which holds the bitbucket api access information",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"webhookSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "WebhookSecret is reference to K8s secret which holds the bitbucket webhook secret (for HMAC validation)",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"bitbucketserverBaseURL": {
						SchemaProps: spec.SchemaProps{
							Description: "BitbucketServerBaseURL is the base URL for API requests to a custom endpoint",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"deleteHookOnFinish": {
						SchemaProps: spec.SchemaProps{
							Description: "DeleteHookOnFinish determines whether to delete the Bitbucket Server hook for the project once the event source is stopped.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"events", "bitbucketserverBaseURL"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerRepository", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_BitbucketServerRepository(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"projectKey": {
						SchemaProps: spec.SchemaProps{
							Description: "ProjectKey is the key of project for which integration needs to set up",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repositorySlug": {
						SchemaProps: spec.SchemaProps{
							Description: "RepositorySlug is the slug of the repository for which integration needs to set up",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"projectKey", "repositorySlug"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_CalendarEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CalendarEventSource describes a time based dependency. One of the fields (schedule, interval, or recurrence) must be passed. Schedule takes precedence over interval; interval takes precedence over recurrence",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"schedule": {
						SchemaProps: spec.SchemaProps{
							Description: "Schedule is a cron-like expression. For reference, see: https://en.wikipedia.org/wiki/Cron",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"interval": {
						SchemaProps: spec.SchemaProps{
							Description: "Interval is a string that describes an interval duration, e.g. 1s, 30m, 2h...",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"exclusionDates": {
						SchemaProps: spec.SchemaProps{
							Description: "ExclusionDates defines the list of DATE-TIME exceptions for recurring events.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"timezone": {
						SchemaProps: spec.SchemaProps{
							Description: "Timezone in which to run the schedule",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"persistence": {
						SchemaProps: spec.SchemaProps{
							Description: "Persistence hold the configuration for event persistence",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventPersistence"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventPersistence", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_CatchupConfiguration(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"enabled": {
						SchemaProps: spec.SchemaProps{
							Description: "Enabled enables to triggered the missed schedule when eventsource restarts",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"maxDuration": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxDuration holds max catchup duration",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_ConfigMapPersistence(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"name": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the configmap",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"createIfNotExist": {
						SchemaProps: spec.SchemaProps{
							Description: "CreateIfNotExist will create configmap if it doesn't exists",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EmitterEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EmitterEventSource describes the event source for emitter More info at https://emitter.io/develop/getting-started/",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"broker": {
						SchemaProps: spec.SchemaProps{
							Description: "Broker URI to connect to.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"channelKey": {
						SchemaProps: spec.SchemaProps{
							Description: "ChannelKey refers to the channel key",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"channelName": {
						SchemaProps: spec.SchemaProps{
							Description: "ChannelName refers to the channel name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username to use to connect to broker",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password to use to connect to broker",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the emitter client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"broker", "channelKey", "channelName"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventPersistence(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"catchup": {
						SchemaProps: spec.SchemaProps{
							Description: "Catchup enables to triggered the missed schedule when eventsource restarts",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CatchupConfiguration"),
						},
					},
					"configMap": {
						SchemaProps: spec.SchemaProps{
							Description: "ConfigMap holds configmap details for persistence",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ConfigMapPersistence"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CatchupConfiguration", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ConfigMapPersistence"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSource is the definition of a eventsource resource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"),
						},
					},
					"spec": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceSpec"),
						},
					},
					"status": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceStatus"),
						},
					},
				},
				Required: []string{"metadata", "spec"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceSpec", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceStatus", "k8s.io/apimachinery/pkg/apis/meta/v1.ObjectMeta"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSourceFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"expression": {
						SchemaProps: spec.SchemaProps{
							Type:   []string{"string"},
							Format: "",
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSourceList(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSourceList is the list of eventsource resources",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"kind": {
						SchemaProps: spec.SchemaProps{
							Description: "Kind is a string value representing the REST resource this object represents. Servers may infer this from the endpoint the client submits requests to. Cannot be updated. In CamelCase. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"apiVersion": {
						SchemaProps: spec.SchemaProps{
							Description: "APIVersion defines the versioned schema of this representation of an object. Servers should convert recognized schemas to the latest internal value, and may reject unrecognized values. More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#resources",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Default: map[string]interface{}{},
							Ref:     ref("k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"),
						},
					},
					"items": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSource"),
									},
								},
							},
						},
					},
				},
				Required: []string{"metadata", "items"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSource", "k8s.io/apimachinery/pkg/apis/meta/v1.ListMeta"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSourceSpec(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSourceSpec refers to specification of event-source resource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"eventBusName": {
						SchemaProps: spec.SchemaProps{
							Description: "EventBusName references to a EventBus name. By default the value is \"default\"",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"template": {
						SchemaProps: spec.SchemaProps{
							Description: "Template is the pod specification for the event source",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Template"),
						},
					},
					"service": {
						SchemaProps: spec.SchemaProps{
							Description: "Service is the specifications of the service to expose the event source",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Service"),
						},
					},
					"minio": {
						SchemaProps: spec.SchemaProps{
							Description: "Minio event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/common.S3Artifact"),
									},
								},
							},
						},
					},
					"calendar": {
						SchemaProps: spec.SchemaProps{
							Description: "Calendar event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource"),
									},
								},
							},
						},
					},
					"file": {
						SchemaProps: spec.SchemaProps{
							Description: "File event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource"),
									},
								},
							},
						},
					},
					"resource": {
						SchemaProps: spec.SchemaProps{
							Description: "Resource event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource"),
									},
								},
							},
						},
					},
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"),
									},
								},
							},
						},
					},
					"amqp": {
						SchemaProps: spec.SchemaProps{
							Description: "AMQP event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource"),
									},
								},
							},
						},
					},
					"kafka": {
						SchemaProps: spec.SchemaProps{
							Description: "Kafka event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource"),
									},
								},
							},
						},
					},
					"mqtt": {
						SchemaProps: spec.SchemaProps{
							Description: "MQTT event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource"),
									},
								},
							},
						},
					},
					"nats": {
						SchemaProps: spec.SchemaProps{
							Description: "NATS event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventsSource"),
									},
								},
							},
						},
					},
					"sns": {
						SchemaProps: spec.SchemaProps{
							Description: "SNS event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource"),
									},
								},
							},
						},
					},
					"sqs": {
						SchemaProps: spec.SchemaProps{
							Description: "SQS event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource"),
									},
								},
							},
						},
					},
					"pubSub": {
						SchemaProps: spec.SchemaProps{
							Description: "PubSub event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource"),
									},
								},
							},
						},
					},
					"github": {
						SchemaProps: spec.SchemaProps{
							Description: "Github event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource"),
									},
								},
							},
						},
					},
					"gitlab": {
						SchemaProps: spec.SchemaProps{
							Description: "Gitlab event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource"),
									},
								},
							},
						},
					},
					"hdfs": {
						SchemaProps: spec.SchemaProps{
							Description: "HDFS event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource"),
									},
								},
							},
						},
					},
					"slack": {
						SchemaProps: spec.SchemaProps{
							Description: "Slack event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource"),
									},
								},
							},
						},
					},
					"storageGrid": {
						SchemaProps: spec.SchemaProps{
							Description: "StorageGrid event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource"),
									},
								},
							},
						},
					},
					"azureEventsHub": {
						SchemaProps: spec.SchemaProps{
							Description: "AzureEventsHub event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AzureEventsHubEventSource"),
									},
								},
							},
						},
					},
					"stripe": {
						SchemaProps: spec.SchemaProps{
							Description: "Stripe event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StripeEventSource"),
									},
								},
							},
						},
					},
					"emitter": {
						SchemaProps: spec.SchemaProps{
							Description: "Emitter event source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EmitterEventSource"),
									},
								},
							},
						},
					},
					"redis": {
						SchemaProps: spec.SchemaProps{
							Description: "Redis event source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisEventSource"),
									},
								},
							},
						},
					},
					"nsq": {
						SchemaProps: spec.SchemaProps{
							Description: "NSQ event source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NSQEventSource"),
									},
								},
							},
						},
					},
					"pulsar": {
						SchemaProps: spec.SchemaProps{
							Description: "Pulsar event source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PulsarEventSource"),
									},
								},
							},
						},
					},
					"generic": {
						SchemaProps: spec.SchemaProps{
							Description: "Generic event source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GenericEventSource"),
									},
								},
							},
						},
					},
					"replicas": {
						SchemaProps: spec.SchemaProps{
							Description: "Replicas is the event source deployment replicas",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"bitbucketserver": {
						SchemaProps: spec.SchemaProps{
							Description: "Bitbucket Server event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerEventSource"),
									},
								},
							},
						},
					},
					"bitbucket": {
						SchemaProps: spec.SchemaProps{
							Description: "Bitbucket event sources",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketEventSource"),
									},
								},
							},
						},
					},
					"redisStream": {
						SchemaProps: spec.SchemaProps{
							Description: "Redis stream source",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisStreamEventSource"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.S3Artifact", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AMQPEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.AzureEventsHubEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.BitbucketServerEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.CalendarEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EmitterEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.FileEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GenericEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GitlabEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.HDFSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.MQTTEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSEventsSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NSQEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PubSubEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.PulsarEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.RedisStreamEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SNSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SQSEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Service", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.SlackEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StripeEventSource", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Template", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookEventSource"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_EventSourceStatus(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "EventSourceStatus holds the status of the event-source resource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"conditions": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "type",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Conditions are the latest available observations of a resource's current state.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/common.Condition"),
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Condition"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_FileEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "FileEventSource describes an event-source for file related events.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"eventType": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of file operations to watch Refer https://github.com/fsnotify/fsnotify/blob/master/fsnotify.go for more information",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"watchPathConfig": {
						SchemaProps: spec.SchemaProps{
							Description: "WatchPathConfig contains configuration about the file path to watch",
							Default:     map[string]interface{}{},
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WatchPathConfig"),
						},
					},
					"polling": {
						SchemaProps: spec.SchemaProps{
							Description: "Use polling instead of inotify",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"eventType", "watchPathConfig"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WatchPathConfig"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GenericEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GenericEventSource refers to a generic event source. It can be used to implement a custom event source.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL of the gRPC server that implements the event source.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"config": {
						SchemaProps: spec.SchemaProps{
							Description: "Config is the event source configuration",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"insecure": {
						SchemaProps: spec.SchemaProps{
							Description: "Insecure determines the type of connection.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"authSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "AuthSecret holds a secret selector that contains a bearer token for authentication",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"url", "config"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GithubAppCreds(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"privateKey": {
						SchemaProps: spec.SchemaProps{
							Description: "PrivateKey refers to a K8s secret containing the GitHub app private key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"appID": {
						SchemaProps: spec.SchemaProps{
							Description: "AppID refers to the GitHub App ID for the application you created",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"installationID": {
						SchemaProps: spec.SchemaProps{
							Description: "InstallationID refers to the Installation ID of the GitHub app you created and installed",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"privateKey", "appID", "installationID"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GithubEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GithubEventSource refers to event-source for github related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"id": {
						SchemaProps: spec.SchemaProps{
							Description: "Id is the webhook's id Deprecated: This is not used at all, will be removed in v1.6",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook refers to the configuration required to run a http server",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"owner": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedOwner refers to GitHub owner name i.e. argoproj Deprecated: use Repositories instead. Will be unsupported in v 1.6",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"repository": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedRepository refers to GitHub repo name i.e. argo-events Deprecated: use Repositories instead. Will be unsupported in v 1.6",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Events refer to Github events to which the event source will subscribe",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"apiToken": {
						SchemaProps: spec.SchemaProps{
							Description: "APIToken refers to a K8s secret containing github api token",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"webhookSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "WebhookSecret refers to K8s secret containing GitHub webhook secret https://developer.github.com/webhooks/securing/",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"insecure": {
						SchemaProps: spec.SchemaProps{
							Description: "Insecure tls verification",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"active": {
						SchemaProps: spec.SchemaProps{
							Description: "Active refers to status of the webhook for event deliveries. https://developer.github.com/webhooks/creating/#active",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"contentType": {
						SchemaProps: spec.SchemaProps{
							Description: "ContentType of the event delivery",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"githubBaseURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub base URL (for GitHub Enterprise)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"githubUploadURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHub upload URL (for GitHub Enterprise)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"deleteHookOnFinish": {
						SchemaProps: spec.SchemaProps{
							Description: "DeleteHookOnFinish determines whether to delete the GitHub hook for the repository once the event source is stopped.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"repositories": {
						SchemaProps: spec.SchemaProps{
							Description: "Repositories holds the information of repositories, which uses repo owner as the key, and list of repo names as the value. Not required if Organizations is set.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.OwnedRepositories"),
									},
								},
							},
						},
					},
					"organizations": {
						SchemaProps: spec.SchemaProps{
							Description: "Organizations holds the names of organizations (used for organization level webhooks). Not required if Repositories is set.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"githubApp": {
						SchemaProps: spec.SchemaProps{
							Description: "GitHubApp holds the GitHub app credentials",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubAppCreds"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"events"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.GithubAppCreds", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.OwnedRepositories", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_GitlabEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "GitlabEventSource refers to event-source related to Gitlab events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook holds configuration to run a http server",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"projectID": {
						SchemaProps: spec.SchemaProps{
							Description: "DeprecatedProjectID is the id of project for which integration needs to setup Deprecated: use Projects instead. Will be unsupported in v 1.7",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Description: "Events are gitlab event to listen to. Refer https://github.com/xanzy/go-gitlab/blob/bf34eca5d13a9f4c3f501d8a97b8ac226d55e4d9/projects.go#L794.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"accessToken": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessToken references to k8 secret which holds the gitlab api access information",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"enableSSLVerification": {
						SchemaProps: spec.SchemaProps{
							Description: "EnableSSLVerification to enable ssl verification",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"gitlabBaseURL": {
						SchemaProps: spec.SchemaProps{
							Description: "GitlabBaseURL is the base URL for API requests to a custom endpoint",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"deleteHookOnFinish": {
						SchemaProps: spec.SchemaProps{
							Description: "DeleteHookOnFinish determines whether to delete the GitLab hook for the project once the event source is stopped.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"projects": {
						SchemaProps: spec.SchemaProps{
							Description: "List of project IDs or project namespace paths like \"whynowy/test\"",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"secretToken": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretToken references to k8 secret which holds the Secret Token used by webhook config",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"events", "gitlabBaseURL"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_HDFSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "HDFSEventSource refers to event-source for HDFS related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"directory": {
						SchemaProps: spec.SchemaProps{
							Description: "Directory to watch for events",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathRegexp": {
						SchemaProps: spec.SchemaProps{
							Description: "PathRegexp is regexp of relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of file operations to watch",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"checkInterval": {
						SchemaProps: spec.SchemaProps{
							Description: "CheckInterval is a string that describes an interval duration to check the directory state, e.g. 1s, 30m, 2h... (defaults to 1m)",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"addresses": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"hdfsUser": {
						SchemaProps: spec.SchemaProps{
							Description: "HDFSUser is the user to access HDFS file system. It is ignored if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbCCacheSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbCCacheSecret is the secret selector for Kerberos ccache Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbKeytabSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbKeytabSecret is the secret selector for Kerberos keytab Either ccache or keytab can be set to use Kerberos.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"krbUsername": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbUsername is the Kerberos username used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbRealm": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbRealm is the Kerberos realm used with Kerberos keytab It must be set if keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"krbConfigConfigMap": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbConfig is the configmap selector for Kerberos config as string It must be set if either ccache or keytab is used.",
							Ref:         ref("k8s.io/api/core/v1.ConfigMapKeySelector"),
						},
					},
					"krbServicePrincipalName": {
						SchemaProps: spec.SchemaProps{
							Description: "KrbServicePrincipalName is the principal name of Kerberos service It must be set if either ccache or keytab is used.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"directory", "type", "addresses"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.ConfigMapKeySelector", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_KafkaConsumerGroup(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"groupName": {
						SchemaProps: spec.SchemaProps{
							Description: "The name for the consumer group to use",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"oldest": {
						SchemaProps: spec.SchemaProps{
							Description: "When starting up a new group do we want to start from the oldest event (true) or the newest event (false), defaults to false",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"rebalanceStrategy": {
						SchemaProps: spec.SchemaProps{
							Description: "Rebalance strategy can be one of: sticky, roundrobin, range. Range is the default.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"groupName"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_KafkaEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "KafkaEventSource refers to event-source for Kafka related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to kafka cluster, multiple URLs separated by comma",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"partition": {
						SchemaProps: spec.SchemaProps{
							Description: "Partition name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the kafka client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"consumerGroup": {
						SchemaProps: spec.SchemaProps{
							Description: "Consumer group for kafka client",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaConsumerGroup"),
						},
					},
					"limitEventsPerSecond": {
						SchemaProps: spec.SchemaProps{
							Description: "Sets a limit on how many events get read from kafka per second.",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Description: "Specify what kafka version is being connected to enables certain features in sarama, defaults to 1.0.0",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"sasl": {
						SchemaProps: spec.SchemaProps{
							Description: "SASL configuration for the kafka client",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.SASLConfig"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
					"config": {
						SchemaProps: spec.SchemaProps{
							Description: "Yaml format Sarama config for Kafka connection. It follows the struct of sarama.Config. See https://github.com/Shopify/sarama/blob/main/config.go e.g.\n\nconsumer:\n  fetch:\n    min: 1\nnet:\n  MaxOpenRequests: 5",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"url", "partition", "topic"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.SASLConfig", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.KafkaConsumerGroup"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_MQTTEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "MQTTEventSource refers to event-source for MQTT related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to connect to broker",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"clientId": {
						SchemaProps: spec.SchemaProps{
							Description: "ClientID is the id of the client",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "ConnectionBackoff holds backoff applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the mqtt client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"url", "topic", "clientId"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_NATSAuth(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NATSAuth refers to the auth info for NATS EventSource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"basic": {
						SchemaProps: spec.SchemaProps{
							Description: "Baisc auth with username and password",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.BasicAuth"),
						},
					},
					"token": {
						SchemaProps: spec.SchemaProps{
							Description: "Token used to connect",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"nkey": {
						SchemaProps: spec.SchemaProps{
							Description: "NKey used to connect",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"credential": {
						SchemaProps: spec.SchemaProps{
							Description: "credential used to connect",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.BasicAuth", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_NATSEventsSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NATSEventsSource refers to event-source for NATS related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL to connect to NATS cluster",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subject": {
						SchemaProps: spec.SchemaProps{
							Description: "Subject holds the name of the subject onto which messages are published",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "ConnectionBackoff holds backoff applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the nats client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"auth": {
						SchemaProps: spec.SchemaProps{
							Description: "Auth information",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSAuth"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"url", "subject"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.NATSAuth"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_NSQEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "NSQEventSource describes the event source for NSQ PubSub More info at https://godoc.org/github.com/nsqio/go-nsq",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hostAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "HostAddress is the address of the host for NSQ lookup",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic to subscribe to.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"channel": {
						SchemaProps: spec.SchemaProps{
							Description: "Channel used for subscription",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the nsq client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"hostAddress", "topic", "channel"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_OwnedRepositories(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"owner": {
						SchemaProps: spec.SchemaProps{
							Description: "Organization or user name",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"names": {
						SchemaProps: spec.SchemaProps{
							Description: "Repository names",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_PubSubEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PubSubEventSource refers to event-source for GCP PubSub related events.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"projectID": {
						SchemaProps: spec.SchemaProps{
							Description: "ProjectID is GCP project ID for the subscription. Required if you run Argo Events outside of GKE/GCE. (otherwise, the default value is its project)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topicProjectID": {
						SchemaProps: spec.SchemaProps{
							Description: "TopicProjectID is GCP project ID for the topic. By default, it is same as ProjectID.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"topic": {
						SchemaProps: spec.SchemaProps{
							Description: "Topic to which the subscription should belongs. Required if you want the eventsource to create a new subscription. If you specify this field along with an existing subscription, it will be verified whether it actually belongs to the specified topic.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"subscriptionID": {
						SchemaProps: spec.SchemaProps{
							Description: "SubscriptionID is ID of subscription. Required if you use existing subscription. The default value will be auto generated hash based on this eventsource setting, so the subscription might be recreated every time you update the setting, which has a possibility of event loss.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"credentialSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "CredentialSecret references to the secret that contains JSON credentials to access GCP. If it is missing, it implicitly uses Workload Identity to access. https://cloud.google.com/kubernetes-engine/docs/how-to/workload-identity",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"deleteSubscriptionOnFinish": {
						SchemaProps: spec.SchemaProps{
							Description: "DeleteSubscriptionOnFinish determines whether to delete the GCP PubSub subscription once the event source is stopped.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_PulsarEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "PulsarEventSource describes the event source for Apache Pulsar",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"topics": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the topics to subscribe to.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"type": {
						SchemaProps: spec.SchemaProps{
							Description: "Type of the subscription. Only \"exclusive\" and \"shared\" is supported. Defaults to exclusive.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "Configure the service URL for the Pulsar service.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tlsTrustCertsSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Trusted TLS certificate secret.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"tlsAllowInsecureConnection": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the Pulsar client accept untrusted TLS certificate from broker.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tlsValidateHostname": {
						SchemaProps: spec.SchemaProps{
							Description: "Whether the Pulsar client verify the validity of the host name from broker.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the pulsar client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"connectionBackoff": {
						SchemaProps: spec.SchemaProps{
							Description: "Backoff holds parameters applied to connection.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Backoff"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"authTokenSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Authentication token for the pulsar client.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"topics", "url"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Backoff", "github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_RedisEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RedisEventSource describes an event source for the Redis PubSub. More info at https://godoc.org/github.com/go-redis/redis#example-PubSub",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hostAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "HostAddress refers to the address of the Redis host/server",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password required for authentication if any.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace to use to retrieve the password from. It should only be specified if password is declared",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"db": {
						SchemaProps: spec.SchemaProps{
							Description: "DB to use. If not specified, default DB 0 will be used.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"channels": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the redis client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username required for ACL style authentication if any.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"hostAddress", "channels"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_RedisStreamEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "RedisStreamEventSource describes an event source for Redis streams (https://redis.io/topics/streams-intro)",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"hostAddress": {
						SchemaProps: spec.SchemaProps{
							Description: "HostAddress refers to the address of the Redis host/server (master instance)",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"password": {
						SchemaProps: spec.SchemaProps{
							Description: "Password required for authentication if any.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"db": {
						SchemaProps: spec.SchemaProps{
							Description: "DB to use. If not specified, default DB 0 will be used.",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"streams": {
						SchemaProps: spec.SchemaProps{
							Description: "Streams to look for entries. XREADGROUP is used on all streams using a single consumer group.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"maxMsgCountPerRead": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxMsgCountPerRead holds the maximum number of messages per stream that will be read in each XREADGROUP of all streams Example: if there are 2 streams and MaxMsgCountPerRead=10, then each XREADGROUP may read upto a total of 20 messages. Same as COUNT option in XREADGROUP(https://redis.io/topics/streams-intro). Defaults to 10",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
					"consumerGroup": {
						SchemaProps: spec.SchemaProps{
							Description: "ConsumerGroup refers to the Redis stream consumer group that will be created on all redis streams. Messages are read through this group. Defaults to 'argo-events-cg'",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"tls": {
						SchemaProps: spec.SchemaProps{
							Description: "TLS configuration for the redis client.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.TLSConfig"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
					"username": {
						SchemaProps: spec.SchemaProps{
							Description: "Username required for ACL style authentication if any.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"hostAddress", "streams"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.TLSConfig", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_ResourceEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceEventSource refers to a event-source for K8s resource related events.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"namespace": {
						SchemaProps: spec.SchemaProps{
							Description: "Namespace where resource is deployed",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter is applied on the metadata of the resource If you apply filter, then the internal event informer will only monitor objects that pass the filter.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter"),
						},
					},
					"group": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"version": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"resource": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"eventTypes": {
						SchemaProps: spec.SchemaProps{
							Description: "EventTypes is the list of event type to watch. Possible values are - ADD, UPDATE and DELETE.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"namespace", "group", "version", "resource", "eventTypes"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.ResourceFilter"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_ResourceFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "ResourceFilter contains K8s ObjectMeta information to further filter resource event objects",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Description: "Prefix filter is applied on the resource name.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"labels": {
						SchemaProps: spec.SchemaProps{
							Description: "Labels provide listing options to K8s API to watch resource/s. Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/label-selectors/ for more info.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Selector"),
									},
								},
							},
						},
					},
					"fields": {
						SchemaProps: spec.SchemaProps{
							Description: "Fields provide field filters similar to K8s field selector (see https://kubernetes.io/docs/concepts/overview/working-with-objects/field-selectors/). Unlike K8s field selector, it supports arbitrary fileds like \"spec.serviceAccountName\", and the value could be a string or a regex. Same as K8s field selector, operator \"=\", \"==\" and \"!=\" are supported.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Selector"),
									},
								},
							},
						},
					},
					"createdBy": {
						SchemaProps: spec.SchemaProps{
							Description: "If resource is created before the specified time then the event is treated as valid.",
							Default:     map[string]interface{}{},
							Ref:         ref("k8s.io/apimachinery/pkg/apis/meta/v1.Time"),
						},
					},
					"afterStart": {
						SchemaProps: spec.SchemaProps{
							Description: "If the resource is created after the start time then the event is treated as valid.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.Selector", "k8s.io/apimachinery/pkg/apis/meta/v1.Time"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SNSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SNSEventSource refers to event-source for AWS SNS related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook configuration for http server",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"topicArn": {
						SchemaProps: spec.SchemaProps{
							Description: "TopicArn",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"accessKey": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessKey refers K8s secret containing aws access key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"secretKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretKey refers K8s secret containing aws secret key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Description: "Region is AWS region",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"roleARN": {
						SchemaProps: spec.SchemaProps{
							Description: "RoleARN is the Amazon Resource Name (ARN) of the role to assume.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"validateSignature": {
						SchemaProps: spec.SchemaProps{
							Description: "ValidateSignature is boolean that can be set to true for SNS signature verification",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint configures connection to a specific SNS endpoint instead of Amazons servers",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"topicArn", "region"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SQSEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SQSEventSource refers to event-source for AWS SQS related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"accessKey": {
						SchemaProps: spec.SchemaProps{
							Description: "AccessKey refers K8s secret containing aws access key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"secretKey": {
						SchemaProps: spec.SchemaProps{
							Description: "SecretKey refers K8s secret containing aws secret key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Description: "Region is AWS region",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"queue": {
						SchemaProps: spec.SchemaProps{
							Description: "Queue is AWS SQS queue to listen to for messages",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"waitTimeSeconds": {
						SchemaProps: spec.SchemaProps{
							Description: "WaitTimeSeconds is The duration (in seconds) for which the call waits for a message to arrive in the queue before returning.",
							Default:     0,
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"roleARN": {
						SchemaProps: spec.SchemaProps{
							Description: "RoleARN is the Amazon Resource Name (ARN) of the role to assume.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"jsonBody": {
						SchemaProps: spec.SchemaProps{
							Description: "JSONBody specifies that all event body payload coming from this source will be JSON",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"queueAccountId": {
						SchemaProps: spec.SchemaProps{
							Description: "QueueAccountID is the ID of the account that created the queue to monitor",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"dlq": {
						SchemaProps: spec.SchemaProps{
							Description: "DLQ specifies if a dead-letter queue is configured for messages that can't be processed successfully. If set to true, messages with invalid payload won't be acknowledged to allow to forward them farther to the dead-letter queue. The default value is false.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "Endpoint configures connection to a specific SQS endpoint instead of Amazons servers",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"sessionToken": {
						SchemaProps: spec.SchemaProps{
							Description: "SessionToken refers to K8s secret containing AWS temporary credentials(STS) session token",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
				},
				Required: []string{"region", "queue", "waitTimeSeconds"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_Selector(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Selector represents conditional operation to select K8s objects.",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"key": {
						SchemaProps: spec.SchemaProps{
							Description: "Key name",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"operation": {
						SchemaProps: spec.SchemaProps{
							Description: "Supported operations like ==, !=, <=, >= etc. Defaults to ==. Refer https://kubernetes.io/docs/concepts/overview/working-with-objects/labels/#label-selectors for more info.",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"value": {
						SchemaProps: spec.SchemaProps{
							Description: "Value",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"key", "value"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_Service(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Service holds the service information eventsource exposes",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"ports": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-list-map-keys": []interface{}{
									"port",
									"protocol",
								},
								"x-kubernetes-list-type":       "map",
								"x-kubernetes-patch-merge-key": "port",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "The list of ports that are exposed by this ClusterIP service.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.ServicePort"),
									},
								},
							},
						},
					},
					"clusterIP": {
						SchemaProps: spec.SchemaProps{
							Description: "clusterIP is the IP address of the service and is usually assigned randomly by the master. If an address is specified manually and is not in use by others, it will be allocated to the service; otherwise, creation of the service will fail. This field can not be changed through updates. Valid values are \"None\", empty string (\"\"), or a valid IP address. \"None\" can be specified for headless services when proxying is not required. More info: https://kubernetes.io/docs/concepts/services-networking/service/#virtual-ips-and-service-proxies",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.ServicePort"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_SlackEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "SlackEventSource refers to event-source for Slack related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"signingSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "Slack App signing secret",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"token": {
						SchemaProps: spec.SchemaProps{
							Description: "Token for URL verification handshake",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook holds configuration for a REST endpoint",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_StorageGridEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageGridEventSource refers to event-source for StorageGrid related events",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook holds configuration for a REST endpoint",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"events": {
						SchemaProps: spec.SchemaProps{
							Type: []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter on object key which caused the notification.",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridFilter"),
						},
					},
					"topicArn": {
						SchemaProps: spec.SchemaProps{
							Description: "TopicArn",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"bucket": {
						SchemaProps: spec.SchemaProps{
							Description: "Name of the bucket to register notifications for.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"region": {
						SchemaProps: spec.SchemaProps{
							Description: "S3 region. Defaults to us-east-1",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"authToken": {
						SchemaProps: spec.SchemaProps{
							Description: "Auth token for storagegrid api",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"apiURL": {
						SchemaProps: spec.SchemaProps{
							Description: "APIURL is the url of the storagegrid api.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
				Required: []string{"topicArn", "bucket", "authToken", "apiURL"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.StorageGridFilter", "github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_StorageGridFilter(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StorageGridFilter represents filters to apply to bucket notifications for specifying constraints on objects",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"prefix": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
					"suffix": {
						SchemaProps: spec.SchemaProps{
							Default: "",
							Type:    []string{"string"},
							Format:  "",
						},
					},
				},
				Required: []string{"prefix", "suffix"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_StripeEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "StripeEventSource describes the event source for stripe webhook notifications More info at https://stripe.com/docs/webhooks",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"webhook": {
						SchemaProps: spec.SchemaProps{
							Description: "Webhook holds configuration for a REST endpoint",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext"),
						},
					},
					"createWebhook": {
						SchemaProps: spec.SchemaProps{
							Description: "CreateWebhook if specified creates a new webhook programmatically.",
							Type:        []string{"boolean"},
							Format:      "",
						},
					},
					"apiKey": {
						SchemaProps: spec.SchemaProps{
							Description: "APIKey refers to K8s secret that holds Stripe API key. Used only if CreateWebhook is enabled.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"eventFilter": {
						SchemaProps: spec.SchemaProps{
							Description: "EventFilter describes the type of events to listen to. If not specified, all types of events will be processed. More info at https://stripe.com/docs/api/events/list",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.WebhookContext", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_Template(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "Template holds the information of an EventSource deployment template",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata sets the pods's metadata, i.e. annotations and labels",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/common.Metadata"),
						},
					},
					"serviceAccountName": {
						SchemaProps: spec.SchemaProps{
							Description: "ServiceAccountName is the name of the ServiceAccount to use to run event source pod. More info: https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"container": {
						SchemaProps: spec.SchemaProps{
							Description: "Container is the main container image to run in the event source pod",
							Ref:         ref("k8s.io/api/core/v1.Container"),
						},
					},
					"volumes": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "Volumes is a list of volumes that can be mounted by containers in an eventsource.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Volume"),
									},
								},
							},
						},
					},
					"securityContext": {
						SchemaProps: spec.SchemaProps{
							Description: "SecurityContext holds pod-level security attributes and common container settings. Optional: Defaults to empty.  See type description for default values of each field.",
							Ref:         ref("k8s.io/api/core/v1.PodSecurityContext"),
						},
					},
					"affinity": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's scheduling constraints",
							Ref:         ref("k8s.io/api/core/v1.Affinity"),
						},
					},
					"tolerations": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, the pod's tolerations.",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.Toleration"),
									},
								},
							},
						},
					},
					"nodeSelector": {
						SchemaProps: spec.SchemaProps{
							Description: "NodeSelector is a selector which must be true for the pod to fit on a node. Selector which must match a node's labels for the pod to be scheduled on that node. More info: https://kubernetes.io/docs/concepts/configuration/assign-pod-node/",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"imagePullSecrets": {
						VendorExtensible: spec.VendorExtensible{
							Extensions: spec.Extensions{
								"x-kubernetes-patch-merge-key": "name",
								"x-kubernetes-patch-strategy":  "merge",
							},
						},
						SchemaProps: spec.SchemaProps{
							Description: "ImagePullSecrets is an optional list of references to secrets in the same namespace to use for pulling any of the images used by this PodSpec. If specified, these secrets will be passed to individual puller implementations for them to use. For example, in the case of docker, only DockerConfig type secrets are honored. More info: https://kubernetes.io/docs/concepts/containers/images#specifying-imagepullsecrets-on-a-pod",
							Type:        []string{"array"},
							Items: &spec.SchemaOrArray{
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: map[string]interface{}{},
										Ref:     ref("k8s.io/api/core/v1.LocalObjectReference"),
									},
								},
							},
						},
					},
					"priorityClassName": {
						SchemaProps: spec.SchemaProps{
							Description: "If specified, indicates the EventSource pod's priority. \"system-node-critical\" and \"system-cluster-critical\" are two special keywords which indicate the highest priorities with the former being the highest priority. Any other name must be defined by creating a PriorityClass object with that name. If not specified, the pod priority will be default or zero if there is no default. More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"priority": {
						SchemaProps: spec.SchemaProps{
							Description: "The priority value. Various system components use this field to find the priority of the EventSource pod. When Priority Admission Controller is enabled, it prevents users from setting this field. The admission controller populates this field from PriorityClassName. The higher the value, the higher the priority. More info: https://kubernetes.io/docs/concepts/configuration/pod-priority-preemption/",
							Type:        []string{"integer"},
							Format:      "int32",
						},
					},
				},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/common.Metadata", "k8s.io/api/core/v1.Affinity", "k8s.io/api/core/v1.Container", "k8s.io/api/core/v1.LocalObjectReference", "k8s.io/api/core/v1.PodSecurityContext", "k8s.io/api/core/v1.Toleration", "k8s.io/api/core/v1.Volume"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_WatchPathConfig(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Type: []string{"object"},
				Properties: map[string]spec.Schema{
					"directory": {
						SchemaProps: spec.SchemaProps{
							Description: "Directory to watch for events",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"path": {
						SchemaProps: spec.SchemaProps{
							Description: "Path is relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"pathRegexp": {
						SchemaProps: spec.SchemaProps{
							Description: "PathRegexp is regexp of relative path of object to watch with respect to the directory",
							Type:        []string{"string"},
							Format:      "",
						},
					},
				},
				Required: []string{"directory"},
			},
		},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_WebhookContext(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "WebhookContext holds a general purpose REST API context",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "REST API endpoint",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"method": {
						SchemaProps: spec.SchemaProps{
							Description: "Method is HTTP request method that indicates the desired action to be performed for a given resource. See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port on which HTTP server is listening for incoming events.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the url of the server.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverCertSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerCertPath refers the file that contains the cert.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"serverKeySecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerKeyPath refers the file that contains private key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"authSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "AuthSecret holds a secret selector that contains a bearer token for authentication",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"maxPayloadSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxPayloadSize is the maximum webhook payload size that the server will accept. Requests exceeding that limit will be rejected with \"request too large\" response. Default value: 1048576 (1MB).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
				},
				Required: []string{"endpoint", "method", "port", "url"},
			},
		},
		Dependencies: []string{
			"k8s.io/api/core/v1.SecretKeySelector"},
	}
}

func schema_pkg_apis_eventsource_v1alpha1_WebhookEventSource(ref common.ReferenceCallback) common.OpenAPIDefinition {
	return common.OpenAPIDefinition{
		Schema: spec.Schema{
			SchemaProps: spec.SchemaProps{
				Description: "CalendarEventSource describes an HTTP based EventSource",
				Type:        []string{"object"},
				Properties: map[string]spec.Schema{
					"endpoint": {
						SchemaProps: spec.SchemaProps{
							Description: "REST API endpoint",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"method": {
						SchemaProps: spec.SchemaProps{
							Description: "Method is HTTP request method that indicates the desired action to be performed for a given resource. See RFC7231 Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"port": {
						SchemaProps: spec.SchemaProps{
							Description: "Port on which HTTP server is listening for incoming events.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"url": {
						SchemaProps: spec.SchemaProps{
							Description: "URL is the url of the server.",
							Default:     "",
							Type:        []string{"string"},
							Format:      "",
						},
					},
					"serverCertSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerCertPath refers the file that contains the cert.",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"serverKeySecret": {
						SchemaProps: spec.SchemaProps{
							Description: "ServerKeyPath refers the file that contains private key",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"metadata": {
						SchemaProps: spec.SchemaProps{
							Description: "Metadata holds the user defined metadata which will passed along the event payload.",
							Type:        []string{"object"},
							AdditionalProperties: &spec.SchemaOrBool{
								Allows: true,
								Schema: &spec.Schema{
									SchemaProps: spec.SchemaProps{
										Default: "",
										Type:    []string{"string"},
										Format:  "",
									},
								},
							},
						},
					},
					"authSecret": {
						SchemaProps: spec.SchemaProps{
							Description: "AuthSecret holds a secret selector that contains a bearer token for authentication",
							Ref:         ref("k8s.io/api/core/v1.SecretKeySelector"),
						},
					},
					"maxPayloadSize": {
						SchemaProps: spec.SchemaProps{
							Description: "MaxPayloadSize is the maximum webhook payload size that the server will accept. Requests exceeding that limit will be rejected with \"request too large\" response. Default value: 1048576 (1MB).",
							Type:        []string{"integer"},
							Format:      "int64",
						},
					},
					"filter": {
						SchemaProps: spec.SchemaProps{
							Description: "Filter",
							Ref:         ref("github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter"),
						},
					},
				},
				Required: []string{"endpoint", "method", "port", "url"},
			},
		},
		Dependencies: []string{
			"github.com/argoproj/argo-events/pkg/apis/eventsource/v1alpha1.EventSourceFilter", "k8s.io/api/core/v1.SecretKeySelector"},
	}
}
