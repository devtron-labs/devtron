// Code generated by protoc-gen-go. DO NOT EDIT.
// source: hdfs.proto

package hadoop_hdfs

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import hadoop_common "github.com/colinmarc/hdfs/protocol/hadoop_common"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// *
// Types of recognized storage media.
type StorageTypeProto int32

const (
	StorageTypeProto_DISK     StorageTypeProto = 1
	StorageTypeProto_SSD      StorageTypeProto = 2
	StorageTypeProto_ARCHIVE  StorageTypeProto = 3
	StorageTypeProto_RAM_DISK StorageTypeProto = 4
)

var StorageTypeProto_name = map[int32]string{
	1: "DISK",
	2: "SSD",
	3: "ARCHIVE",
	4: "RAM_DISK",
}
var StorageTypeProto_value = map[string]int32{
	"DISK":     1,
	"SSD":      2,
	"ARCHIVE":  3,
	"RAM_DISK": 4,
}

func (x StorageTypeProto) Enum() *StorageTypeProto {
	p := new(StorageTypeProto)
	*p = x
	return p
}
func (x StorageTypeProto) String() string {
	return proto.EnumName(StorageTypeProto_name, int32(x))
}
func (x *StorageTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(StorageTypeProto_value, data, "StorageTypeProto")
	if err != nil {
		return err
	}
	*x = StorageTypeProto(value)
	return nil
}
func (StorageTypeProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

// *
// Cipher suite.
type CipherSuiteProto int32

const (
	CipherSuiteProto_UNKNOWN           CipherSuiteProto = 1
	CipherSuiteProto_AES_CTR_NOPADDING CipherSuiteProto = 2
)

var CipherSuiteProto_name = map[int32]string{
	1: "UNKNOWN",
	2: "AES_CTR_NOPADDING",
}
var CipherSuiteProto_value = map[string]int32{
	"UNKNOWN":           1,
	"AES_CTR_NOPADDING": 2,
}

func (x CipherSuiteProto) Enum() *CipherSuiteProto {
	p := new(CipherSuiteProto)
	*p = x
	return p
}
func (x CipherSuiteProto) String() string {
	return proto.EnumName(CipherSuiteProto_name, int32(x))
}
func (x *CipherSuiteProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CipherSuiteProto_value, data, "CipherSuiteProto")
	if err != nil {
		return err
	}
	*x = CipherSuiteProto(value)
	return nil
}
func (CipherSuiteProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

// *
// Crypto protocol version used to access encrypted files.
type CryptoProtocolVersionProto int32

const (
	CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION CryptoProtocolVersionProto = 1
	CryptoProtocolVersionProto_ENCRYPTION_ZONES         CryptoProtocolVersionProto = 2
)

var CryptoProtocolVersionProto_name = map[int32]string{
	1: "UNKNOWN_PROTOCOL_VERSION",
	2: "ENCRYPTION_ZONES",
}
var CryptoProtocolVersionProto_value = map[string]int32{
	"UNKNOWN_PROTOCOL_VERSION": 1,
	"ENCRYPTION_ZONES":         2,
}

func (x CryptoProtocolVersionProto) Enum() *CryptoProtocolVersionProto {
	p := new(CryptoProtocolVersionProto)
	*p = x
	return p
}
func (x CryptoProtocolVersionProto) String() string {
	return proto.EnumName(CryptoProtocolVersionProto_name, int32(x))
}
func (x *CryptoProtocolVersionProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(CryptoProtocolVersionProto_value, data, "CryptoProtocolVersionProto")
	if err != nil {
		return err
	}
	*x = CryptoProtocolVersionProto(value)
	return nil
}
func (CryptoProtocolVersionProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{2} }

// *
// Checksum algorithms/types used in HDFS
// Make sure this enum's integer values match enum values' id properties defined
// in org.apache.hadoop.util.DataChecksum.Type
type ChecksumTypeProto int32

const (
	ChecksumTypeProto_CHECKSUM_NULL   ChecksumTypeProto = 0
	ChecksumTypeProto_CHECKSUM_CRC32  ChecksumTypeProto = 1
	ChecksumTypeProto_CHECKSUM_CRC32C ChecksumTypeProto = 2
)

var ChecksumTypeProto_name = map[int32]string{
	0: "CHECKSUM_NULL",
	1: "CHECKSUM_CRC32",
	2: "CHECKSUM_CRC32C",
}
var ChecksumTypeProto_value = map[string]int32{
	"CHECKSUM_NULL":   0,
	"CHECKSUM_CRC32":  1,
	"CHECKSUM_CRC32C": 2,
}

func (x ChecksumTypeProto) Enum() *ChecksumTypeProto {
	p := new(ChecksumTypeProto)
	*p = x
	return p
}
func (x ChecksumTypeProto) String() string {
	return proto.EnumName(ChecksumTypeProto_name, int32(x))
}
func (x *ChecksumTypeProto) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(ChecksumTypeProto_value, data, "ChecksumTypeProto")
	if err != nil {
		return err
	}
	*x = ChecksumTypeProto(value)
	return nil
}
func (ChecksumTypeProto) EnumDescriptor() ([]byte, []int) { return fileDescriptor8, []int{3} }

type DatanodeInfoProto_AdminState int32

const (
	DatanodeInfoProto_NORMAL                  DatanodeInfoProto_AdminState = 0
	DatanodeInfoProto_DECOMMISSION_INPROGRESS DatanodeInfoProto_AdminState = 1
	DatanodeInfoProto_DECOMMISSIONED          DatanodeInfoProto_AdminState = 2
)

var DatanodeInfoProto_AdminState_name = map[int32]string{
	0: "NORMAL",
	1: "DECOMMISSION_INPROGRESS",
	2: "DECOMMISSIONED",
}
var DatanodeInfoProto_AdminState_value = map[string]int32{
	"NORMAL":                  0,
	"DECOMMISSION_INPROGRESS": 1,
	"DECOMMISSIONED":          2,
}

func (x DatanodeInfoProto_AdminState) Enum() *DatanodeInfoProto_AdminState {
	p := new(DatanodeInfoProto_AdminState)
	*p = x
	return p
}
func (x DatanodeInfoProto_AdminState) String() string {
	return proto.EnumName(DatanodeInfoProto_AdminState_name, int32(x))
}
func (x *DatanodeInfoProto_AdminState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeInfoProto_AdminState_value, data, "DatanodeInfoProto_AdminState")
	if err != nil {
		return err
	}
	*x = DatanodeInfoProto_AdminState(value)
	return nil
}
func (DatanodeInfoProto_AdminState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor8, []int{4, 0}
}

type DatanodeStorageProto_StorageState int32

const (
	DatanodeStorageProto_NORMAL           DatanodeStorageProto_StorageState = 0
	DatanodeStorageProto_READ_ONLY_SHARED DatanodeStorageProto_StorageState = 1
)

var DatanodeStorageProto_StorageState_name = map[int32]string{
	0: "NORMAL",
	1: "READ_ONLY_SHARED",
}
var DatanodeStorageProto_StorageState_value = map[string]int32{
	"NORMAL":           0,
	"READ_ONLY_SHARED": 1,
}

func (x DatanodeStorageProto_StorageState) Enum() *DatanodeStorageProto_StorageState {
	p := new(DatanodeStorageProto_StorageState)
	*p = x
	return p
}
func (x DatanodeStorageProto_StorageState) String() string {
	return proto.EnumName(DatanodeStorageProto_StorageState_name, int32(x))
}
func (x *DatanodeStorageProto_StorageState) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(DatanodeStorageProto_StorageState_value, data, "DatanodeStorageProto_StorageState")
	if err != nil {
		return err
	}
	*x = DatanodeStorageProto_StorageState(value)
	return nil
}
func (DatanodeStorageProto_StorageState) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor8, []int{5, 0}
}

type HdfsFileStatusProto_FileType int32

const (
	HdfsFileStatusProto_IS_DIR     HdfsFileStatusProto_FileType = 1
	HdfsFileStatusProto_IS_FILE    HdfsFileStatusProto_FileType = 2
	HdfsFileStatusProto_IS_SYMLINK HdfsFileStatusProto_FileType = 3
)

var HdfsFileStatusProto_FileType_name = map[int32]string{
	1: "IS_DIR",
	2: "IS_FILE",
	3: "IS_SYMLINK",
}
var HdfsFileStatusProto_FileType_value = map[string]int32{
	"IS_DIR":     1,
	"IS_FILE":    2,
	"IS_SYMLINK": 3,
}

func (x HdfsFileStatusProto_FileType) Enum() *HdfsFileStatusProto_FileType {
	p := new(HdfsFileStatusProto_FileType)
	*p = x
	return p
}
func (x HdfsFileStatusProto_FileType) String() string {
	return proto.EnumName(HdfsFileStatusProto_FileType_name, int32(x))
}
func (x *HdfsFileStatusProto_FileType) UnmarshalJSON(data []byte) error {
	value, err := proto.UnmarshalJSONEnum(HdfsFileStatusProto_FileType_value, data, "HdfsFileStatusProto_FileType")
	if err != nil {
		return err
	}
	*x = HdfsFileStatusProto_FileType(value)
	return nil
}
func (HdfsFileStatusProto_FileType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor8, []int{25, 0}
}

// *
// Extended block idenfies a block
type ExtendedBlockProto struct {
	PoolId           *string `protobuf:"bytes,1,req,name=poolId" json:"poolId,omitempty"`
	BlockId          *uint64 `protobuf:"varint,2,req,name=blockId" json:"blockId,omitempty"`
	GenerationStamp  *uint64 `protobuf:"varint,3,req,name=generationStamp" json:"generationStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,4,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ExtendedBlockProto) Reset()                    { *m = ExtendedBlockProto{} }
func (m *ExtendedBlockProto) String() string            { return proto.CompactTextString(m) }
func (*ExtendedBlockProto) ProtoMessage()               {}
func (*ExtendedBlockProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{0} }

const Default_ExtendedBlockProto_NumBytes uint64 = 0

func (m *ExtendedBlockProto) GetPoolId() string {
	if m != nil && m.PoolId != nil {
		return *m.PoolId
	}
	return ""
}

func (m *ExtendedBlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *ExtendedBlockProto) GetGenerationStamp() uint64 {
	if m != nil && m.GenerationStamp != nil {
		return *m.GenerationStamp
	}
	return 0
}

func (m *ExtendedBlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_ExtendedBlockProto_NumBytes
}

// *
// Identifies a Datanode
type DatanodeIDProto struct {
	IpAddr       *string `protobuf:"bytes,1,req,name=ipAddr" json:"ipAddr,omitempty"`
	HostName     *string `protobuf:"bytes,2,req,name=hostName" json:"hostName,omitempty"`
	DatanodeUuid *string `protobuf:"bytes,3,req,name=datanodeUuid" json:"datanodeUuid,omitempty"`
	// upgraded clusters this is the same
	// as the original StorageID of the
	// Datanode.
	XferPort         *uint32 `protobuf:"varint,4,req,name=xferPort" json:"xferPort,omitempty"`
	InfoPort         *uint32 `protobuf:"varint,5,req,name=infoPort" json:"infoPort,omitempty"`
	IpcPort          *uint32 `protobuf:"varint,6,req,name=ipcPort" json:"ipcPort,omitempty"`
	InfoSecurePort   *uint32 `protobuf:"varint,7,opt,name=infoSecurePort,def=0" json:"infoSecurePort,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeIDProto) Reset()                    { *m = DatanodeIDProto{} }
func (m *DatanodeIDProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeIDProto) ProtoMessage()               {}
func (*DatanodeIDProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{1} }

const Default_DatanodeIDProto_InfoSecurePort uint32 = 0

func (m *DatanodeIDProto) GetIpAddr() string {
	if m != nil && m.IpAddr != nil {
		return *m.IpAddr
	}
	return ""
}

func (m *DatanodeIDProto) GetHostName() string {
	if m != nil && m.HostName != nil {
		return *m.HostName
	}
	return ""
}

func (m *DatanodeIDProto) GetDatanodeUuid() string {
	if m != nil && m.DatanodeUuid != nil {
		return *m.DatanodeUuid
	}
	return ""
}

func (m *DatanodeIDProto) GetXferPort() uint32 {
	if m != nil && m.XferPort != nil {
		return *m.XferPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoPort() uint32 {
	if m != nil && m.InfoPort != nil {
		return *m.InfoPort
	}
	return 0
}

func (m *DatanodeIDProto) GetIpcPort() uint32 {
	if m != nil && m.IpcPort != nil {
		return *m.IpcPort
	}
	return 0
}

func (m *DatanodeIDProto) GetInfoSecurePort() uint32 {
	if m != nil && m.InfoSecurePort != nil {
		return *m.InfoSecurePort
	}
	return Default_DatanodeIDProto_InfoSecurePort
}

// *
// Datanode local information
type DatanodeLocalInfoProto struct {
	SoftwareVersion  *string `protobuf:"bytes,1,req,name=softwareVersion" json:"softwareVersion,omitempty"`
	ConfigVersion    *string `protobuf:"bytes,2,req,name=configVersion" json:"configVersion,omitempty"`
	Uptime           *uint64 `protobuf:"varint,3,req,name=uptime" json:"uptime,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *DatanodeLocalInfoProto) Reset()                    { *m = DatanodeLocalInfoProto{} }
func (m *DatanodeLocalInfoProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeLocalInfoProto) ProtoMessage()               {}
func (*DatanodeLocalInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{2} }

func (m *DatanodeLocalInfoProto) GetSoftwareVersion() string {
	if m != nil && m.SoftwareVersion != nil {
		return *m.SoftwareVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetConfigVersion() string {
	if m != nil && m.ConfigVersion != nil {
		return *m.ConfigVersion
	}
	return ""
}

func (m *DatanodeLocalInfoProto) GetUptime() uint64 {
	if m != nil && m.Uptime != nil {
		return *m.Uptime
	}
	return 0
}

// *
// DatanodeInfo array
type DatanodeInfosProto struct {
	Datanodes        []*DatanodeInfoProto `protobuf:"bytes,1,rep,name=datanodes" json:"datanodes,omitempty"`
	XXX_unrecognized []byte               `json:"-"`
}

func (m *DatanodeInfosProto) Reset()                    { *m = DatanodeInfosProto{} }
func (m *DatanodeInfosProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeInfosProto) ProtoMessage()               {}
func (*DatanodeInfosProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{3} }

func (m *DatanodeInfosProto) GetDatanodes() []*DatanodeInfoProto {
	if m != nil {
		return m.Datanodes
	}
	return nil
}

// *
// The status of a Datanode
type DatanodeInfoProto struct {
	Id                  *DatanodeIDProto              `protobuf:"bytes,1,req,name=id" json:"id,omitempty"`
	Capacity            *uint64                       `protobuf:"varint,2,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed             *uint64                       `protobuf:"varint,3,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining           *uint64                       `protobuf:"varint,4,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed       *uint64                       `protobuf:"varint,5,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	LastUpdate          *uint64                       `protobuf:"varint,6,opt,name=lastUpdate,def=0" json:"lastUpdate,omitempty"`
	XceiverCount        *uint32                       `protobuf:"varint,7,opt,name=xceiverCount,def=0" json:"xceiverCount,omitempty"`
	Location            *string                       `protobuf:"bytes,8,opt,name=location" json:"location,omitempty"`
	AdminState          *DatanodeInfoProto_AdminState `protobuf:"varint,10,opt,name=adminState,enum=hadoop.hdfs.DatanodeInfoProto_AdminState,def=0" json:"adminState,omitempty"`
	CacheCapacity       *uint64                       `protobuf:"varint,11,opt,name=cacheCapacity,def=0" json:"cacheCapacity,omitempty"`
	CacheUsed           *uint64                       `protobuf:"varint,12,opt,name=cacheUsed,def=0" json:"cacheUsed,omitempty"`
	LastUpdateMonotonic *uint64                       `protobuf:"varint,13,opt,name=lastUpdateMonotonic,def=0" json:"lastUpdateMonotonic,omitempty"`
	UpgradeDomain       *string                       `protobuf:"bytes,14,opt,name=upgradeDomain" json:"upgradeDomain,omitempty"`
	XXX_unrecognized    []byte                        `json:"-"`
}

func (m *DatanodeInfoProto) Reset()                    { *m = DatanodeInfoProto{} }
func (m *DatanodeInfoProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeInfoProto) ProtoMessage()               {}
func (*DatanodeInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{4} }

const Default_DatanodeInfoProto_Capacity uint64 = 0
const Default_DatanodeInfoProto_DfsUsed uint64 = 0
const Default_DatanodeInfoProto_Remaining uint64 = 0
const Default_DatanodeInfoProto_BlockPoolUsed uint64 = 0
const Default_DatanodeInfoProto_LastUpdate uint64 = 0
const Default_DatanodeInfoProto_XceiverCount uint32 = 0
const Default_DatanodeInfoProto_AdminState DatanodeInfoProto_AdminState = DatanodeInfoProto_NORMAL
const Default_DatanodeInfoProto_CacheCapacity uint64 = 0
const Default_DatanodeInfoProto_CacheUsed uint64 = 0
const Default_DatanodeInfoProto_LastUpdateMonotonic uint64 = 0

func (m *DatanodeInfoProto) GetId() *DatanodeIDProto {
	if m != nil {
		return m.Id
	}
	return nil
}

func (m *DatanodeInfoProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_DatanodeInfoProto_Capacity
}

func (m *DatanodeInfoProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_DatanodeInfoProto_DfsUsed
}

func (m *DatanodeInfoProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_DatanodeInfoProto_Remaining
}

func (m *DatanodeInfoProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_DatanodeInfoProto_BlockPoolUsed
}

func (m *DatanodeInfoProto) GetLastUpdate() uint64 {
	if m != nil && m.LastUpdate != nil {
		return *m.LastUpdate
	}
	return Default_DatanodeInfoProto_LastUpdate
}

func (m *DatanodeInfoProto) GetXceiverCount() uint32 {
	if m != nil && m.XceiverCount != nil {
		return *m.XceiverCount
	}
	return Default_DatanodeInfoProto_XceiverCount
}

func (m *DatanodeInfoProto) GetLocation() string {
	if m != nil && m.Location != nil {
		return *m.Location
	}
	return ""
}

func (m *DatanodeInfoProto) GetAdminState() DatanodeInfoProto_AdminState {
	if m != nil && m.AdminState != nil {
		return *m.AdminState
	}
	return Default_DatanodeInfoProto_AdminState
}

func (m *DatanodeInfoProto) GetCacheCapacity() uint64 {
	if m != nil && m.CacheCapacity != nil {
		return *m.CacheCapacity
	}
	return Default_DatanodeInfoProto_CacheCapacity
}

func (m *DatanodeInfoProto) GetCacheUsed() uint64 {
	if m != nil && m.CacheUsed != nil {
		return *m.CacheUsed
	}
	return Default_DatanodeInfoProto_CacheUsed
}

func (m *DatanodeInfoProto) GetLastUpdateMonotonic() uint64 {
	if m != nil && m.LastUpdateMonotonic != nil {
		return *m.LastUpdateMonotonic
	}
	return Default_DatanodeInfoProto_LastUpdateMonotonic
}

func (m *DatanodeInfoProto) GetUpgradeDomain() string {
	if m != nil && m.UpgradeDomain != nil {
		return *m.UpgradeDomain
	}
	return ""
}

// *
// Represents a storage available on the datanode
type DatanodeStorageProto struct {
	StorageUuid      *string                            `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	State            *DatanodeStorageProto_StorageState `protobuf:"varint,2,opt,name=state,enum=hadoop.hdfs.DatanodeStorageProto_StorageState,def=0" json:"state,omitempty"`
	StorageType      *StorageTypeProto                  `protobuf:"varint,3,opt,name=storageType,enum=hadoop.hdfs.StorageTypeProto,def=1" json:"storageType,omitempty"`
	XXX_unrecognized []byte                             `json:"-"`
}

func (m *DatanodeStorageProto) Reset()                    { *m = DatanodeStorageProto{} }
func (m *DatanodeStorageProto) String() string            { return proto.CompactTextString(m) }
func (*DatanodeStorageProto) ProtoMessage()               {}
func (*DatanodeStorageProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{5} }

const Default_DatanodeStorageProto_State DatanodeStorageProto_StorageState = DatanodeStorageProto_NORMAL
const Default_DatanodeStorageProto_StorageType StorageTypeProto = StorageTypeProto_DISK

func (m *DatanodeStorageProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *DatanodeStorageProto) GetState() DatanodeStorageProto_StorageState {
	if m != nil && m.State != nil {
		return *m.State
	}
	return Default_DatanodeStorageProto_State
}

func (m *DatanodeStorageProto) GetStorageType() StorageTypeProto {
	if m != nil && m.StorageType != nil {
		return *m.StorageType
	}
	return Default_DatanodeStorageProto_StorageType
}

type StorageReportProto struct {
	StorageUuid      *string               `protobuf:"bytes,1,req,name=storageUuid" json:"storageUuid,omitempty"`
	Failed           *bool                 `protobuf:"varint,2,opt,name=failed,def=0" json:"failed,omitempty"`
	Capacity         *uint64               `protobuf:"varint,3,opt,name=capacity,def=0" json:"capacity,omitempty"`
	DfsUsed          *uint64               `protobuf:"varint,4,opt,name=dfsUsed,def=0" json:"dfsUsed,omitempty"`
	Remaining        *uint64               `protobuf:"varint,5,opt,name=remaining,def=0" json:"remaining,omitempty"`
	BlockPoolUsed    *uint64               `protobuf:"varint,6,opt,name=blockPoolUsed,def=0" json:"blockPoolUsed,omitempty"`
	Storage          *DatanodeStorageProto `protobuf:"bytes,7,opt,name=storage" json:"storage,omitempty"`
	XXX_unrecognized []byte                `json:"-"`
}

func (m *StorageReportProto) Reset()                    { *m = StorageReportProto{} }
func (m *StorageReportProto) String() string            { return proto.CompactTextString(m) }
func (*StorageReportProto) ProtoMessage()               {}
func (*StorageReportProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{6} }

const Default_StorageReportProto_Failed bool = false
const Default_StorageReportProto_Capacity uint64 = 0
const Default_StorageReportProto_DfsUsed uint64 = 0
const Default_StorageReportProto_Remaining uint64 = 0
const Default_StorageReportProto_BlockPoolUsed uint64 = 0

func (m *StorageReportProto) GetStorageUuid() string {
	if m != nil && m.StorageUuid != nil {
		return *m.StorageUuid
	}
	return ""
}

func (m *StorageReportProto) GetFailed() bool {
	if m != nil && m.Failed != nil {
		return *m.Failed
	}
	return Default_StorageReportProto_Failed
}

func (m *StorageReportProto) GetCapacity() uint64 {
	if m != nil && m.Capacity != nil {
		return *m.Capacity
	}
	return Default_StorageReportProto_Capacity
}

func (m *StorageReportProto) GetDfsUsed() uint64 {
	if m != nil && m.DfsUsed != nil {
		return *m.DfsUsed
	}
	return Default_StorageReportProto_DfsUsed
}

func (m *StorageReportProto) GetRemaining() uint64 {
	if m != nil && m.Remaining != nil {
		return *m.Remaining
	}
	return Default_StorageReportProto_Remaining
}

func (m *StorageReportProto) GetBlockPoolUsed() uint64 {
	if m != nil && m.BlockPoolUsed != nil {
		return *m.BlockPoolUsed
	}
	return Default_StorageReportProto_BlockPoolUsed
}

func (m *StorageReportProto) GetStorage() *DatanodeStorageProto {
	if m != nil {
		return m.Storage
	}
	return nil
}

// *
// Summary of a file or directory
type ContentSummaryProto struct {
	Length           *uint64                     `protobuf:"varint,1,req,name=length" json:"length,omitempty"`
	FileCount        *uint64                     `protobuf:"varint,2,req,name=fileCount" json:"fileCount,omitempty"`
	DirectoryCount   *uint64                     `protobuf:"varint,3,req,name=directoryCount" json:"directoryCount,omitempty"`
	Quota            *uint64                     `protobuf:"varint,4,req,name=quota" json:"quota,omitempty"`
	SpaceConsumed    *uint64                     `protobuf:"varint,5,req,name=spaceConsumed" json:"spaceConsumed,omitempty"`
	SpaceQuota       *uint64                     `protobuf:"varint,6,req,name=spaceQuota" json:"spaceQuota,omitempty"`
	TypeQuotaInfos   *StorageTypeQuotaInfosProto `protobuf:"bytes,7,opt,name=typeQuotaInfos" json:"typeQuotaInfos,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ContentSummaryProto) Reset()                    { *m = ContentSummaryProto{} }
func (m *ContentSummaryProto) String() string            { return proto.CompactTextString(m) }
func (*ContentSummaryProto) ProtoMessage()               {}
func (*ContentSummaryProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{7} }

func (m *ContentSummaryProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *ContentSummaryProto) GetFileCount() uint64 {
	if m != nil && m.FileCount != nil {
		return *m.FileCount
	}
	return 0
}

func (m *ContentSummaryProto) GetDirectoryCount() uint64 {
	if m != nil && m.DirectoryCount != nil {
		return *m.DirectoryCount
	}
	return 0
}

func (m *ContentSummaryProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceConsumed() uint64 {
	if m != nil && m.SpaceConsumed != nil {
		return *m.SpaceConsumed
	}
	return 0
}

func (m *ContentSummaryProto) GetSpaceQuota() uint64 {
	if m != nil && m.SpaceQuota != nil {
		return *m.SpaceQuota
	}
	return 0
}

func (m *ContentSummaryProto) GetTypeQuotaInfos() *StorageTypeQuotaInfosProto {
	if m != nil {
		return m.TypeQuotaInfos
	}
	return nil
}

// *
// Summary of quota usage of a directory
type QuotaUsageProto struct {
	FileAndDirectoryCount *uint64                     `protobuf:"varint,1,req,name=fileAndDirectoryCount" json:"fileAndDirectoryCount,omitempty"`
	Quota                 *uint64                     `protobuf:"varint,2,req,name=quota" json:"quota,omitempty"`
	SpaceConsumed         *uint64                     `protobuf:"varint,3,req,name=spaceConsumed" json:"spaceConsumed,omitempty"`
	SpaceQuota            *uint64                     `protobuf:"varint,4,req,name=spaceQuota" json:"spaceQuota,omitempty"`
	TypeQuotaInfos        *StorageTypeQuotaInfosProto `protobuf:"bytes,5,opt,name=typeQuotaInfos" json:"typeQuotaInfos,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *QuotaUsageProto) Reset()                    { *m = QuotaUsageProto{} }
func (m *QuotaUsageProto) String() string            { return proto.CompactTextString(m) }
func (*QuotaUsageProto) ProtoMessage()               {}
func (*QuotaUsageProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{8} }

func (m *QuotaUsageProto) GetFileAndDirectoryCount() uint64 {
	if m != nil && m.FileAndDirectoryCount != nil {
		return *m.FileAndDirectoryCount
	}
	return 0
}

func (m *QuotaUsageProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *QuotaUsageProto) GetSpaceConsumed() uint64 {
	if m != nil && m.SpaceConsumed != nil {
		return *m.SpaceConsumed
	}
	return 0
}

func (m *QuotaUsageProto) GetSpaceQuota() uint64 {
	if m != nil && m.SpaceQuota != nil {
		return *m.SpaceQuota
	}
	return 0
}

func (m *QuotaUsageProto) GetTypeQuotaInfos() *StorageTypeQuotaInfosProto {
	if m != nil {
		return m.TypeQuotaInfos
	}
	return nil
}

// *
// Storage type quota and usage information of a file or directory
type StorageTypeQuotaInfosProto struct {
	TypeQuotaInfo    []*StorageTypeQuotaInfoProto `protobuf:"bytes,1,rep,name=typeQuotaInfo" json:"typeQuotaInfo,omitempty"`
	XXX_unrecognized []byte                       `json:"-"`
}

func (m *StorageTypeQuotaInfosProto) Reset()                    { *m = StorageTypeQuotaInfosProto{} }
func (m *StorageTypeQuotaInfosProto) String() string            { return proto.CompactTextString(m) }
func (*StorageTypeQuotaInfosProto) ProtoMessage()               {}
func (*StorageTypeQuotaInfosProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{9} }

func (m *StorageTypeQuotaInfosProto) GetTypeQuotaInfo() []*StorageTypeQuotaInfoProto {
	if m != nil {
		return m.TypeQuotaInfo
	}
	return nil
}

type StorageTypeQuotaInfoProto struct {
	Type             *StorageTypeProto `protobuf:"varint,1,req,name=type,enum=hadoop.hdfs.StorageTypeProto" json:"type,omitempty"`
	Quota            *uint64           `protobuf:"varint,2,req,name=quota" json:"quota,omitempty"`
	Consumed         *uint64           `protobuf:"varint,3,req,name=consumed" json:"consumed,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *StorageTypeQuotaInfoProto) Reset()                    { *m = StorageTypeQuotaInfoProto{} }
func (m *StorageTypeQuotaInfoProto) String() string            { return proto.CompactTextString(m) }
func (*StorageTypeQuotaInfoProto) ProtoMessage()               {}
func (*StorageTypeQuotaInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{10} }

func (m *StorageTypeQuotaInfoProto) GetType() StorageTypeProto {
	if m != nil && m.Type != nil {
		return *m.Type
	}
	return StorageTypeProto_DISK
}

func (m *StorageTypeQuotaInfoProto) GetQuota() uint64 {
	if m != nil && m.Quota != nil {
		return *m.Quota
	}
	return 0
}

func (m *StorageTypeQuotaInfoProto) GetConsumed() uint64 {
	if m != nil && m.Consumed != nil {
		return *m.Consumed
	}
	return 0
}

// *
// Contains a list of paths corresponding to corrupt files and a cookie
// used for iterative calls to NameNode.listCorruptFileBlocks.
//
type CorruptFileBlocksProto struct {
	Files            []string `protobuf:"bytes,1,rep,name=files" json:"files,omitempty"`
	Cookie           *string  `protobuf:"bytes,2,req,name=cookie" json:"cookie,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *CorruptFileBlocksProto) Reset()                    { *m = CorruptFileBlocksProto{} }
func (m *CorruptFileBlocksProto) String() string            { return proto.CompactTextString(m) }
func (*CorruptFileBlocksProto) ProtoMessage()               {}
func (*CorruptFileBlocksProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{11} }

func (m *CorruptFileBlocksProto) GetFiles() []string {
	if m != nil {
		return m.Files
	}
	return nil
}

func (m *CorruptFileBlocksProto) GetCookie() string {
	if m != nil && m.Cookie != nil {
		return *m.Cookie
	}
	return ""
}

// *
// File or Directory permision - same spec as posix
type FsPermissionProto struct {
	Perm             *uint32 `protobuf:"varint,1,req,name=perm" json:"perm,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *FsPermissionProto) Reset()                    { *m = FsPermissionProto{} }
func (m *FsPermissionProto) String() string            { return proto.CompactTextString(m) }
func (*FsPermissionProto) ProtoMessage()               {}
func (*FsPermissionProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{12} }

func (m *FsPermissionProto) GetPerm() uint32 {
	if m != nil && m.Perm != nil {
		return *m.Perm
	}
	return 0
}

// *
// A list of storage types.
type StorageTypesProto struct {
	StorageTypes     []StorageTypeProto `protobuf:"varint,1,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *StorageTypesProto) Reset()                    { *m = StorageTypesProto{} }
func (m *StorageTypesProto) String() string            { return proto.CompactTextString(m) }
func (*StorageTypesProto) ProtoMessage()               {}
func (*StorageTypesProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{13} }

func (m *StorageTypesProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

// *
// Block replica storage policy.
type BlockStoragePolicyProto struct {
	PolicyId *uint32 `protobuf:"varint,1,req,name=policyId" json:"policyId,omitempty"`
	Name     *string `protobuf:"bytes,2,req,name=name" json:"name,omitempty"`
	// a list of storage types for storing the block replicas when creating a
	// block.
	CreationPolicy *StorageTypesProto `protobuf:"bytes,3,req,name=creationPolicy" json:"creationPolicy,omitempty"`
	// A list of storage types for creation fallback storage.
	CreationFallbackPolicy    *StorageTypesProto `protobuf:"bytes,4,opt,name=creationFallbackPolicy" json:"creationFallbackPolicy,omitempty"`
	ReplicationFallbackPolicy *StorageTypesProto `protobuf:"bytes,5,opt,name=replicationFallbackPolicy" json:"replicationFallbackPolicy,omitempty"`
	XXX_unrecognized          []byte             `json:"-"`
}

func (m *BlockStoragePolicyProto) Reset()                    { *m = BlockStoragePolicyProto{} }
func (m *BlockStoragePolicyProto) String() string            { return proto.CompactTextString(m) }
func (*BlockStoragePolicyProto) ProtoMessage()               {}
func (*BlockStoragePolicyProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{14} }

func (m *BlockStoragePolicyProto) GetPolicyId() uint32 {
	if m != nil && m.PolicyId != nil {
		return *m.PolicyId
	}
	return 0
}

func (m *BlockStoragePolicyProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *BlockStoragePolicyProto) GetCreationPolicy() *StorageTypesProto {
	if m != nil {
		return m.CreationPolicy
	}
	return nil
}

func (m *BlockStoragePolicyProto) GetCreationFallbackPolicy() *StorageTypesProto {
	if m != nil {
		return m.CreationFallbackPolicy
	}
	return nil
}

func (m *BlockStoragePolicyProto) GetReplicationFallbackPolicy() *StorageTypesProto {
	if m != nil {
		return m.ReplicationFallbackPolicy
	}
	return nil
}

// *
// A LocatedBlock gives information about a block and its location.
type LocatedBlockProto struct {
	B            *ExtendedBlockProto       `protobuf:"bytes,1,req,name=b" json:"b,omitempty"`
	Offset       *uint64                   `protobuf:"varint,2,req,name=offset" json:"offset,omitempty"`
	Locs         []*DatanodeInfoProto      `protobuf:"bytes,3,rep,name=locs" json:"locs,omitempty"`
	Corrupt      *bool                     `protobuf:"varint,4,req,name=corrupt" json:"corrupt,omitempty"`
	BlockToken   *hadoop_common.TokenProto `protobuf:"bytes,5,req,name=blockToken" json:"blockToken,omitempty"`
	IsCached     []bool                    `protobuf:"varint,6,rep,packed,name=isCached" json:"isCached,omitempty"`
	StorageTypes []StorageTypeProto        `protobuf:"varint,7,rep,name=storageTypes,enum=hadoop.hdfs.StorageTypeProto" json:"storageTypes,omitempty"`
	StorageIDs   []string                  `protobuf:"bytes,8,rep,name=storageIDs" json:"storageIDs,omitempty"`
	// striped block related fields
	BlockIndices     []byte                      `protobuf:"bytes,9,opt,name=blockIndices" json:"blockIndices,omitempty"`
	BlockTokens      []*hadoop_common.TokenProto `protobuf:"bytes,10,rep,name=blockTokens" json:"blockTokens,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *LocatedBlockProto) Reset()                    { *m = LocatedBlockProto{} }
func (m *LocatedBlockProto) String() string            { return proto.CompactTextString(m) }
func (*LocatedBlockProto) ProtoMessage()               {}
func (*LocatedBlockProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{15} }

func (m *LocatedBlockProto) GetB() *ExtendedBlockProto {
	if m != nil {
		return m.B
	}
	return nil
}

func (m *LocatedBlockProto) GetOffset() uint64 {
	if m != nil && m.Offset != nil {
		return *m.Offset
	}
	return 0
}

func (m *LocatedBlockProto) GetLocs() []*DatanodeInfoProto {
	if m != nil {
		return m.Locs
	}
	return nil
}

func (m *LocatedBlockProto) GetCorrupt() bool {
	if m != nil && m.Corrupt != nil {
		return *m.Corrupt
	}
	return false
}

func (m *LocatedBlockProto) GetBlockToken() *hadoop_common.TokenProto {
	if m != nil {
		return m.BlockToken
	}
	return nil
}

func (m *LocatedBlockProto) GetIsCached() []bool {
	if m != nil {
		return m.IsCached
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageTypes() []StorageTypeProto {
	if m != nil {
		return m.StorageTypes
	}
	return nil
}

func (m *LocatedBlockProto) GetStorageIDs() []string {
	if m != nil {
		return m.StorageIDs
	}
	return nil
}

func (m *LocatedBlockProto) GetBlockIndices() []byte {
	if m != nil {
		return m.BlockIndices
	}
	return nil
}

func (m *LocatedBlockProto) GetBlockTokens() []*hadoop_common.TokenProto {
	if m != nil {
		return m.BlockTokens
	}
	return nil
}

type DataEncryptionKeyProto struct {
	KeyId               *uint32 `protobuf:"varint,1,req,name=keyId" json:"keyId,omitempty"`
	BlockPoolId         *string `protobuf:"bytes,2,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Nonce               []byte  `protobuf:"bytes,3,req,name=nonce" json:"nonce,omitempty"`
	EncryptionKey       []byte  `protobuf:"bytes,4,req,name=encryptionKey" json:"encryptionKey,omitempty"`
	ExpiryDate          *uint64 `protobuf:"varint,5,req,name=expiryDate" json:"expiryDate,omitempty"`
	EncryptionAlgorithm *string `protobuf:"bytes,6,opt,name=encryptionAlgorithm" json:"encryptionAlgorithm,omitempty"`
	XXX_unrecognized    []byte  `json:"-"`
}

func (m *DataEncryptionKeyProto) Reset()                    { *m = DataEncryptionKeyProto{} }
func (m *DataEncryptionKeyProto) String() string            { return proto.CompactTextString(m) }
func (*DataEncryptionKeyProto) ProtoMessage()               {}
func (*DataEncryptionKeyProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{16} }

func (m *DataEncryptionKeyProto) GetKeyId() uint32 {
	if m != nil && m.KeyId != nil {
		return *m.KeyId
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *DataEncryptionKeyProto) GetNonce() []byte {
	if m != nil {
		return m.Nonce
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetEncryptionKey() []byte {
	if m != nil {
		return m.EncryptionKey
	}
	return nil
}

func (m *DataEncryptionKeyProto) GetExpiryDate() uint64 {
	if m != nil && m.ExpiryDate != nil {
		return *m.ExpiryDate
	}
	return 0
}

func (m *DataEncryptionKeyProto) GetEncryptionAlgorithm() string {
	if m != nil && m.EncryptionAlgorithm != nil {
		return *m.EncryptionAlgorithm
	}
	return ""
}

// *
// Encryption information for a file.
type FileEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	Key                   []byte                      `protobuf:"bytes,3,req,name=key" json:"key,omitempty"`
	Iv                    []byte                      `protobuf:"bytes,4,req,name=iv" json:"iv,omitempty"`
	KeyName               *string                     `protobuf:"bytes,5,req,name=keyName" json:"keyName,omitempty"`
	EzKeyVersionName      *string                     `protobuf:"bytes,6,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *FileEncryptionInfoProto) Reset()                    { *m = FileEncryptionInfoProto{} }
func (m *FileEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*FileEncryptionInfoProto) ProtoMessage()               {}
func (*FileEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{17} }

func (m *FileEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *FileEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *FileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *FileEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

func (m *FileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an individual
// file within an encryption zone
type PerFileEncryptionInfoProto struct {
	Key              []byte  `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Iv               []byte  `protobuf:"bytes,2,req,name=iv" json:"iv,omitempty"`
	EzKeyVersionName *string `protobuf:"bytes,3,req,name=ezKeyVersionName" json:"ezKeyVersionName,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *PerFileEncryptionInfoProto) Reset()                    { *m = PerFileEncryptionInfoProto{} }
func (m *PerFileEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*PerFileEncryptionInfoProto) ProtoMessage()               {}
func (*PerFileEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{18} }

func (m *PerFileEncryptionInfoProto) GetKey() []byte {
	if m != nil {
		return m.Key
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetIv() []byte {
	if m != nil {
		return m.Iv
	}
	return nil
}

func (m *PerFileEncryptionInfoProto) GetEzKeyVersionName() string {
	if m != nil && m.EzKeyVersionName != nil {
		return *m.EzKeyVersionName
	}
	return ""
}

// *
// Encryption information for an encryption
// zone
type ZoneEncryptionInfoProto struct {
	Suite                 *CipherSuiteProto           `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	CryptoProtocolVersion *CryptoProtocolVersionProto `protobuf:"varint,2,req,name=cryptoProtocolVersion,enum=hadoop.hdfs.CryptoProtocolVersionProto" json:"cryptoProtocolVersion,omitempty"`
	KeyName               *string                     `protobuf:"bytes,3,req,name=keyName" json:"keyName,omitempty"`
	XXX_unrecognized      []byte                      `json:"-"`
}

func (m *ZoneEncryptionInfoProto) Reset()                    { *m = ZoneEncryptionInfoProto{} }
func (m *ZoneEncryptionInfoProto) String() string            { return proto.CompactTextString(m) }
func (*ZoneEncryptionInfoProto) ProtoMessage()               {}
func (*ZoneEncryptionInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{19} }

func (m *ZoneEncryptionInfoProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *ZoneEncryptionInfoProto) GetCryptoProtocolVersion() CryptoProtocolVersionProto {
	if m != nil && m.CryptoProtocolVersion != nil {
		return *m.CryptoProtocolVersion
	}
	return CryptoProtocolVersionProto_UNKNOWN_PROTOCOL_VERSION
}

func (m *ZoneEncryptionInfoProto) GetKeyName() string {
	if m != nil && m.KeyName != nil {
		return *m.KeyName
	}
	return ""
}

// *
// Cipher option
type CipherOptionProto struct {
	Suite            *CipherSuiteProto `protobuf:"varint,1,req,name=suite,enum=hadoop.hdfs.CipherSuiteProto" json:"suite,omitempty"`
	InKey            []byte            `protobuf:"bytes,2,opt,name=inKey" json:"inKey,omitempty"`
	InIv             []byte            `protobuf:"bytes,3,opt,name=inIv" json:"inIv,omitempty"`
	OutKey           []byte            `protobuf:"bytes,4,opt,name=outKey" json:"outKey,omitempty"`
	OutIv            []byte            `protobuf:"bytes,5,opt,name=outIv" json:"outIv,omitempty"`
	XXX_unrecognized []byte            `json:"-"`
}

func (m *CipherOptionProto) Reset()                    { *m = CipherOptionProto{} }
func (m *CipherOptionProto) String() string            { return proto.CompactTextString(m) }
func (*CipherOptionProto) ProtoMessage()               {}
func (*CipherOptionProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{20} }

func (m *CipherOptionProto) GetSuite() CipherSuiteProto {
	if m != nil && m.Suite != nil {
		return *m.Suite
	}
	return CipherSuiteProto_UNKNOWN
}

func (m *CipherOptionProto) GetInKey() []byte {
	if m != nil {
		return m.InKey
	}
	return nil
}

func (m *CipherOptionProto) GetInIv() []byte {
	if m != nil {
		return m.InIv
	}
	return nil
}

func (m *CipherOptionProto) GetOutKey() []byte {
	if m != nil {
		return m.OutKey
	}
	return nil
}

func (m *CipherOptionProto) GetOutIv() []byte {
	if m != nil {
		return m.OutIv
	}
	return nil
}

// *
// A set of file blocks and their locations.
type LocatedBlocksProto struct {
	FileLength          *uint64                  `protobuf:"varint,1,req,name=fileLength" json:"fileLength,omitempty"`
	Blocks              []*LocatedBlockProto     `protobuf:"bytes,2,rep,name=blocks" json:"blocks,omitempty"`
	UnderConstruction   *bool                    `protobuf:"varint,3,req,name=underConstruction" json:"underConstruction,omitempty"`
	LastBlock           *LocatedBlockProto       `protobuf:"bytes,4,opt,name=lastBlock" json:"lastBlock,omitempty"`
	IsLastBlockComplete *bool                    `protobuf:"varint,5,req,name=isLastBlockComplete" json:"isLastBlockComplete,omitempty"`
	FileEncryptionInfo  *FileEncryptionInfoProto `protobuf:"bytes,6,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	// Optional field for erasure coding
	EcPolicy         *ErasureCodingPolicyProto `protobuf:"bytes,7,opt,name=ecPolicy" json:"ecPolicy,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *LocatedBlocksProto) Reset()                    { *m = LocatedBlocksProto{} }
func (m *LocatedBlocksProto) String() string            { return proto.CompactTextString(m) }
func (*LocatedBlocksProto) ProtoMessage()               {}
func (*LocatedBlocksProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{21} }

func (m *LocatedBlocksProto) GetFileLength() uint64 {
	if m != nil && m.FileLength != nil {
		return *m.FileLength
	}
	return 0
}

func (m *LocatedBlocksProto) GetBlocks() []*LocatedBlockProto {
	if m != nil {
		return m.Blocks
	}
	return nil
}

func (m *LocatedBlocksProto) GetUnderConstruction() bool {
	if m != nil && m.UnderConstruction != nil {
		return *m.UnderConstruction
	}
	return false
}

func (m *LocatedBlocksProto) GetLastBlock() *LocatedBlockProto {
	if m != nil {
		return m.LastBlock
	}
	return nil
}

func (m *LocatedBlocksProto) GetIsLastBlockComplete() bool {
	if m != nil && m.IsLastBlockComplete != nil {
		return *m.IsLastBlockComplete
	}
	return false
}

func (m *LocatedBlocksProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

func (m *LocatedBlocksProto) GetEcPolicy() *ErasureCodingPolicyProto {
	if m != nil {
		return m.EcPolicy
	}
	return nil
}

// *
// ECSchema options entry
type ECSchemaOptionEntryProto struct {
	Key              *string `protobuf:"bytes,1,req,name=key" json:"key,omitempty"`
	Value            *string `protobuf:"bytes,2,req,name=value" json:"value,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *ECSchemaOptionEntryProto) Reset()                    { *m = ECSchemaOptionEntryProto{} }
func (m *ECSchemaOptionEntryProto) String() string            { return proto.CompactTextString(m) }
func (*ECSchemaOptionEntryProto) ProtoMessage()               {}
func (*ECSchemaOptionEntryProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{22} }

func (m *ECSchemaOptionEntryProto) GetKey() string {
	if m != nil && m.Key != nil {
		return *m.Key
	}
	return ""
}

func (m *ECSchemaOptionEntryProto) GetValue() string {
	if m != nil && m.Value != nil {
		return *m.Value
	}
	return ""
}

// *
// ECSchema for erasurecoding
type ECSchemaProto struct {
	CodecName        *string                     `protobuf:"bytes,1,req,name=codecName" json:"codecName,omitempty"`
	DataUnits        *uint32                     `protobuf:"varint,2,req,name=dataUnits" json:"dataUnits,omitempty"`
	ParityUnits      *uint32                     `protobuf:"varint,3,req,name=parityUnits" json:"parityUnits,omitempty"`
	Options          []*ECSchemaOptionEntryProto `protobuf:"bytes,4,rep,name=options" json:"options,omitempty"`
	XXX_unrecognized []byte                      `json:"-"`
}

func (m *ECSchemaProto) Reset()                    { *m = ECSchemaProto{} }
func (m *ECSchemaProto) String() string            { return proto.CompactTextString(m) }
func (*ECSchemaProto) ProtoMessage()               {}
func (*ECSchemaProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{23} }

func (m *ECSchemaProto) GetCodecName() string {
	if m != nil && m.CodecName != nil {
		return *m.CodecName
	}
	return ""
}

func (m *ECSchemaProto) GetDataUnits() uint32 {
	if m != nil && m.DataUnits != nil {
		return *m.DataUnits
	}
	return 0
}

func (m *ECSchemaProto) GetParityUnits() uint32 {
	if m != nil && m.ParityUnits != nil {
		return *m.ParityUnits
	}
	return 0
}

func (m *ECSchemaProto) GetOptions() []*ECSchemaOptionEntryProto {
	if m != nil {
		return m.Options
	}
	return nil
}

type ErasureCodingPolicyProto struct {
	Name             *string        `protobuf:"bytes,1,req,name=name" json:"name,omitempty"`
	Schema           *ECSchemaProto `protobuf:"bytes,2,req,name=schema" json:"schema,omitempty"`
	CellSize         *uint32        `protobuf:"varint,3,req,name=cellSize" json:"cellSize,omitempty"`
	Id               *uint32        `protobuf:"varint,4,req,name=id" json:"id,omitempty"`
	XXX_unrecognized []byte         `json:"-"`
}

func (m *ErasureCodingPolicyProto) Reset()                    { *m = ErasureCodingPolicyProto{} }
func (m *ErasureCodingPolicyProto) String() string            { return proto.CompactTextString(m) }
func (*ErasureCodingPolicyProto) ProtoMessage()               {}
func (*ErasureCodingPolicyProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{24} }

func (m *ErasureCodingPolicyProto) GetName() string {
	if m != nil && m.Name != nil {
		return *m.Name
	}
	return ""
}

func (m *ErasureCodingPolicyProto) GetSchema() *ECSchemaProto {
	if m != nil {
		return m.Schema
	}
	return nil
}

func (m *ErasureCodingPolicyProto) GetCellSize() uint32 {
	if m != nil && m.CellSize != nil {
		return *m.CellSize
	}
	return 0
}

func (m *ErasureCodingPolicyProto) GetId() uint32 {
	if m != nil && m.Id != nil {
		return *m.Id
	}
	return 0
}

// *
// Status of a file, directory or symlink
// Optionally includes a file's block locations if requested by client on the rpc call.
type HdfsFileStatusProto struct {
	FileType         *HdfsFileStatusProto_FileType `protobuf:"varint,1,req,name=fileType,enum=hadoop.hdfs.HdfsFileStatusProto_FileType" json:"fileType,omitempty"`
	Path             []byte                        `protobuf:"bytes,2,req,name=path" json:"path,omitempty"`
	Length           *uint64                       `protobuf:"varint,3,req,name=length" json:"length,omitempty"`
	Permission       *FsPermissionProto            `protobuf:"bytes,4,req,name=permission" json:"permission,omitempty"`
	Owner            *string                       `protobuf:"bytes,5,req,name=owner" json:"owner,omitempty"`
	Group            *string                       `protobuf:"bytes,6,req,name=group" json:"group,omitempty"`
	ModificationTime *uint64                       `protobuf:"varint,7,req,name=modification_time,json=modificationTime" json:"modification_time,omitempty"`
	AccessTime       *uint64                       `protobuf:"varint,8,req,name=access_time,json=accessTime" json:"access_time,omitempty"`
	// Optional fields for symlink
	Symlink []byte `protobuf:"bytes,9,opt,name=symlink" json:"symlink,omitempty"`
	// Optional fields for file
	BlockReplication *uint32             `protobuf:"varint,10,opt,name=block_replication,json=blockReplication,def=0" json:"block_replication,omitempty"`
	Blocksize        *uint64             `protobuf:"varint,11,opt,name=blocksize,def=0" json:"blocksize,omitempty"`
	Locations        *LocatedBlocksProto `protobuf:"bytes,12,opt,name=locations" json:"locations,omitempty"`
	// Optional field for fileId
	FileId      *uint64 `protobuf:"varint,13,opt,name=fileId,def=0" json:"fileId,omitempty"`
	ChildrenNum *int32  `protobuf:"varint,14,opt,name=childrenNum,def=-1" json:"childrenNum,omitempty"`
	// Optional field for file encryption
	FileEncryptionInfo *FileEncryptionInfoProto `protobuf:"bytes,15,opt,name=fileEncryptionInfo" json:"fileEncryptionInfo,omitempty"`
	StoragePolicy      *uint32                  `protobuf:"varint,16,opt,name=storagePolicy,def=0" json:"storagePolicy,omitempty"`
	// Optional field for erasure coding
	EcPolicy         *ErasureCodingPolicyProto `protobuf:"bytes,17,opt,name=ecPolicy" json:"ecPolicy,omitempty"`
	XXX_unrecognized []byte                    `json:"-"`
}

func (m *HdfsFileStatusProto) Reset()                    { *m = HdfsFileStatusProto{} }
func (m *HdfsFileStatusProto) String() string            { return proto.CompactTextString(m) }
func (*HdfsFileStatusProto) ProtoMessage()               {}
func (*HdfsFileStatusProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{25} }

const Default_HdfsFileStatusProto_BlockReplication uint32 = 0
const Default_HdfsFileStatusProto_Blocksize uint64 = 0
const Default_HdfsFileStatusProto_FileId uint64 = 0
const Default_HdfsFileStatusProto_ChildrenNum int32 = -1
const Default_HdfsFileStatusProto_StoragePolicy uint32 = 0

func (m *HdfsFileStatusProto) GetFileType() HdfsFileStatusProto_FileType {
	if m != nil && m.FileType != nil {
		return *m.FileType
	}
	return HdfsFileStatusProto_IS_DIR
}

func (m *HdfsFileStatusProto) GetPath() []byte {
	if m != nil {
		return m.Path
	}
	return nil
}

func (m *HdfsFileStatusProto) GetLength() uint64 {
	if m != nil && m.Length != nil {
		return *m.Length
	}
	return 0
}

func (m *HdfsFileStatusProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *HdfsFileStatusProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *HdfsFileStatusProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *HdfsFileStatusProto) GetModificationTime() uint64 {
	if m != nil && m.ModificationTime != nil {
		return *m.ModificationTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetAccessTime() uint64 {
	if m != nil && m.AccessTime != nil {
		return *m.AccessTime
	}
	return 0
}

func (m *HdfsFileStatusProto) GetSymlink() []byte {
	if m != nil {
		return m.Symlink
	}
	return nil
}

func (m *HdfsFileStatusProto) GetBlockReplication() uint32 {
	if m != nil && m.BlockReplication != nil {
		return *m.BlockReplication
	}
	return Default_HdfsFileStatusProto_BlockReplication
}

func (m *HdfsFileStatusProto) GetBlocksize() uint64 {
	if m != nil && m.Blocksize != nil {
		return *m.Blocksize
	}
	return Default_HdfsFileStatusProto_Blocksize
}

func (m *HdfsFileStatusProto) GetLocations() *LocatedBlocksProto {
	if m != nil {
		return m.Locations
	}
	return nil
}

func (m *HdfsFileStatusProto) GetFileId() uint64 {
	if m != nil && m.FileId != nil {
		return *m.FileId
	}
	return Default_HdfsFileStatusProto_FileId
}

func (m *HdfsFileStatusProto) GetChildrenNum() int32 {
	if m != nil && m.ChildrenNum != nil {
		return *m.ChildrenNum
	}
	return Default_HdfsFileStatusProto_ChildrenNum
}

func (m *HdfsFileStatusProto) GetFileEncryptionInfo() *FileEncryptionInfoProto {
	if m != nil {
		return m.FileEncryptionInfo
	}
	return nil
}

func (m *HdfsFileStatusProto) GetStoragePolicy() uint32 {
	if m != nil && m.StoragePolicy != nil {
		return *m.StoragePolicy
	}
	return Default_HdfsFileStatusProto_StoragePolicy
}

func (m *HdfsFileStatusProto) GetEcPolicy() *ErasureCodingPolicyProto {
	if m != nil {
		return m.EcPolicy
	}
	return nil
}

// *
// HDFS Server Defaults
type FsServerDefaultsProto struct {
	BlockSize           *uint64            `protobuf:"varint,1,req,name=blockSize" json:"blockSize,omitempty"`
	BytesPerChecksum    *uint32            `protobuf:"varint,2,req,name=bytesPerChecksum" json:"bytesPerChecksum,omitempty"`
	WritePacketSize     *uint32            `protobuf:"varint,3,req,name=writePacketSize" json:"writePacketSize,omitempty"`
	Replication         *uint32            `protobuf:"varint,4,req,name=replication" json:"replication,omitempty"`
	FileBufferSize      *uint32            `protobuf:"varint,5,req,name=fileBufferSize" json:"fileBufferSize,omitempty"`
	EncryptDataTransfer *bool              `protobuf:"varint,6,opt,name=encryptDataTransfer,def=0" json:"encryptDataTransfer,omitempty"`
	TrashInterval       *uint64            `protobuf:"varint,7,opt,name=trashInterval,def=0" json:"trashInterval,omitempty"`
	ChecksumType        *ChecksumTypeProto `protobuf:"varint,8,opt,name=checksumType,enum=hadoop.hdfs.ChecksumTypeProto,def=1" json:"checksumType,omitempty"`
	XXX_unrecognized    []byte             `json:"-"`
}

func (m *FsServerDefaultsProto) Reset()                    { *m = FsServerDefaultsProto{} }
func (m *FsServerDefaultsProto) String() string            { return proto.CompactTextString(m) }
func (*FsServerDefaultsProto) ProtoMessage()               {}
func (*FsServerDefaultsProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{26} }

const Default_FsServerDefaultsProto_EncryptDataTransfer bool = false
const Default_FsServerDefaultsProto_TrashInterval uint64 = 0
const Default_FsServerDefaultsProto_ChecksumType ChecksumTypeProto = ChecksumTypeProto_CHECKSUM_CRC32

func (m *FsServerDefaultsProto) GetBlockSize() uint64 {
	if m != nil && m.BlockSize != nil {
		return *m.BlockSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetBytesPerChecksum() uint32 {
	if m != nil && m.BytesPerChecksum != nil {
		return *m.BytesPerChecksum
	}
	return 0
}

func (m *FsServerDefaultsProto) GetWritePacketSize() uint32 {
	if m != nil && m.WritePacketSize != nil {
		return *m.WritePacketSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetReplication() uint32 {
	if m != nil && m.Replication != nil {
		return *m.Replication
	}
	return 0
}

func (m *FsServerDefaultsProto) GetFileBufferSize() uint32 {
	if m != nil && m.FileBufferSize != nil {
		return *m.FileBufferSize
	}
	return 0
}

func (m *FsServerDefaultsProto) GetEncryptDataTransfer() bool {
	if m != nil && m.EncryptDataTransfer != nil {
		return *m.EncryptDataTransfer
	}
	return Default_FsServerDefaultsProto_EncryptDataTransfer
}

func (m *FsServerDefaultsProto) GetTrashInterval() uint64 {
	if m != nil && m.TrashInterval != nil {
		return *m.TrashInterval
	}
	return Default_FsServerDefaultsProto_TrashInterval
}

func (m *FsServerDefaultsProto) GetChecksumType() ChecksumTypeProto {
	if m != nil && m.ChecksumType != nil {
		return *m.ChecksumType
	}
	return Default_FsServerDefaultsProto_ChecksumType
}

// *
// Directory listing
type DirectoryListingProto struct {
	PartialListing   []*HdfsFileStatusProto `protobuf:"bytes,1,rep,name=partialListing" json:"partialListing,omitempty"`
	RemainingEntries *uint32                `protobuf:"varint,2,req,name=remainingEntries" json:"remainingEntries,omitempty"`
	XXX_unrecognized []byte                 `json:"-"`
}

func (m *DirectoryListingProto) Reset()                    { *m = DirectoryListingProto{} }
func (m *DirectoryListingProto) String() string            { return proto.CompactTextString(m) }
func (*DirectoryListingProto) ProtoMessage()               {}
func (*DirectoryListingProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{27} }

func (m *DirectoryListingProto) GetPartialListing() []*HdfsFileStatusProto {
	if m != nil {
		return m.PartialListing
	}
	return nil
}

func (m *DirectoryListingProto) GetRemainingEntries() uint32 {
	if m != nil && m.RemainingEntries != nil {
		return *m.RemainingEntries
	}
	return 0
}

// *
// Status of a snapshottable directory: besides the normal information for
// a directory status, also include snapshot quota, number of snapshots, and
// the full path of the parent directory.
type SnapshottableDirectoryStatusProto struct {
	DirStatus *HdfsFileStatusProto `protobuf:"bytes,1,req,name=dirStatus" json:"dirStatus,omitempty"`
	// Fields specific for snapshottable directory
	SnapshotQuota    *uint32 `protobuf:"varint,2,req,name=snapshot_quota,json=snapshotQuota" json:"snapshot_quota,omitempty"`
	SnapshotNumber   *uint32 `protobuf:"varint,3,req,name=snapshot_number,json=snapshotNumber" json:"snapshot_number,omitempty"`
	ParentFullpath   []byte  `protobuf:"bytes,4,req,name=parent_fullpath,json=parentFullpath" json:"parent_fullpath,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *SnapshottableDirectoryStatusProto) Reset()         { *m = SnapshottableDirectoryStatusProto{} }
func (m *SnapshottableDirectoryStatusProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryStatusProto) ProtoMessage()    {}
func (*SnapshottableDirectoryStatusProto) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{28}
}

func (m *SnapshottableDirectoryStatusProto) GetDirStatus() *HdfsFileStatusProto {
	if m != nil {
		return m.DirStatus
	}
	return nil
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotQuota() uint32 {
	if m != nil && m.SnapshotQuota != nil {
		return *m.SnapshotQuota
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetSnapshotNumber() uint32 {
	if m != nil && m.SnapshotNumber != nil {
		return *m.SnapshotNumber
	}
	return 0
}

func (m *SnapshottableDirectoryStatusProto) GetParentFullpath() []byte {
	if m != nil {
		return m.ParentFullpath
	}
	return nil
}

// *
// Snapshottable directory listing
type SnapshottableDirectoryListingProto struct {
	SnapshottableDirListing []*SnapshottableDirectoryStatusProto `protobuf:"bytes,1,rep,name=snapshottableDirListing" json:"snapshottableDirListing,omitempty"`
	XXX_unrecognized        []byte                               `json:"-"`
}

func (m *SnapshottableDirectoryListingProto) Reset()         { *m = SnapshottableDirectoryListingProto{} }
func (m *SnapshottableDirectoryListingProto) String() string { return proto.CompactTextString(m) }
func (*SnapshottableDirectoryListingProto) ProtoMessage()    {}
func (*SnapshottableDirectoryListingProto) Descriptor() ([]byte, []int) {
	return fileDescriptor8, []int{29}
}

func (m *SnapshottableDirectoryListingProto) GetSnapshottableDirListing() []*SnapshottableDirectoryStatusProto {
	if m != nil {
		return m.SnapshottableDirListing
	}
	return nil
}

// *
// Snapshot diff report entry
type SnapshotDiffReportEntryProto struct {
	Fullpath          []byte  `protobuf:"bytes,1,req,name=fullpath" json:"fullpath,omitempty"`
	ModificationLabel *string `protobuf:"bytes,2,req,name=modificationLabel" json:"modificationLabel,omitempty"`
	TargetPath        []byte  `protobuf:"bytes,3,opt,name=targetPath" json:"targetPath,omitempty"`
	XXX_unrecognized  []byte  `json:"-"`
}

func (m *SnapshotDiffReportEntryProto) Reset()                    { *m = SnapshotDiffReportEntryProto{} }
func (m *SnapshotDiffReportEntryProto) String() string            { return proto.CompactTextString(m) }
func (*SnapshotDiffReportEntryProto) ProtoMessage()               {}
func (*SnapshotDiffReportEntryProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{30} }

func (m *SnapshotDiffReportEntryProto) GetFullpath() []byte {
	if m != nil {
		return m.Fullpath
	}
	return nil
}

func (m *SnapshotDiffReportEntryProto) GetModificationLabel() string {
	if m != nil && m.ModificationLabel != nil {
		return *m.ModificationLabel
	}
	return ""
}

func (m *SnapshotDiffReportEntryProto) GetTargetPath() []byte {
	if m != nil {
		return m.TargetPath
	}
	return nil
}

// *
// Snapshot diff report
type SnapshotDiffReportProto struct {
	// full path of the directory where snapshots were taken
	SnapshotRoot      *string                         `protobuf:"bytes,1,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	FromSnapshot      *string                         `protobuf:"bytes,2,req,name=fromSnapshot" json:"fromSnapshot,omitempty"`
	ToSnapshot        *string                         `protobuf:"bytes,3,req,name=toSnapshot" json:"toSnapshot,omitempty"`
	DiffReportEntries []*SnapshotDiffReportEntryProto `protobuf:"bytes,4,rep,name=diffReportEntries" json:"diffReportEntries,omitempty"`
	XXX_unrecognized  []byte                          `json:"-"`
}

func (m *SnapshotDiffReportProto) Reset()                    { *m = SnapshotDiffReportProto{} }
func (m *SnapshotDiffReportProto) String() string            { return proto.CompactTextString(m) }
func (*SnapshotDiffReportProto) ProtoMessage()               {}
func (*SnapshotDiffReportProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{31} }

func (m *SnapshotDiffReportProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetFromSnapshot() string {
	if m != nil && m.FromSnapshot != nil {
		return *m.FromSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetToSnapshot() string {
	if m != nil && m.ToSnapshot != nil {
		return *m.ToSnapshot
	}
	return ""
}

func (m *SnapshotDiffReportProto) GetDiffReportEntries() []*SnapshotDiffReportEntryProto {
	if m != nil {
		return m.DiffReportEntries
	}
	return nil
}

// *
// Block information
//
// Please be wary of adding additional fields here, since INodeFiles
// need to fit in PB's default max message size of 64MB.
// We restrict the max # of blocks per file
// (dfs.namenode.fs-limits.max-blocks-per-file), but it's better
// to avoid changing this.
type BlockProto struct {
	BlockId          *uint64 `protobuf:"varint,1,req,name=blockId" json:"blockId,omitempty"`
	GenStamp         *uint64 `protobuf:"varint,2,req,name=genStamp" json:"genStamp,omitempty"`
	NumBytes         *uint64 `protobuf:"varint,3,opt,name=numBytes,def=0" json:"numBytes,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *BlockProto) Reset()                    { *m = BlockProto{} }
func (m *BlockProto) String() string            { return proto.CompactTextString(m) }
func (*BlockProto) ProtoMessage()               {}
func (*BlockProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{32} }

const Default_BlockProto_NumBytes uint64 = 0

func (m *BlockProto) GetBlockId() uint64 {
	if m != nil && m.BlockId != nil {
		return *m.BlockId
	}
	return 0
}

func (m *BlockProto) GetGenStamp() uint64 {
	if m != nil && m.GenStamp != nil {
		return *m.GenStamp
	}
	return 0
}

func (m *BlockProto) GetNumBytes() uint64 {
	if m != nil && m.NumBytes != nil {
		return *m.NumBytes
	}
	return Default_BlockProto_NumBytes
}

// *
// Information related to a snapshot
// TODO: add more information
type SnapshotInfoProto struct {
	SnapshotName     *string            `protobuf:"bytes,1,req,name=snapshotName" json:"snapshotName,omitempty"`
	SnapshotRoot     *string            `protobuf:"bytes,2,req,name=snapshotRoot" json:"snapshotRoot,omitempty"`
	Permission       *FsPermissionProto `protobuf:"bytes,3,req,name=permission" json:"permission,omitempty"`
	Owner            *string            `protobuf:"bytes,4,req,name=owner" json:"owner,omitempty"`
	Group            *string            `protobuf:"bytes,5,req,name=group" json:"group,omitempty"`
	CreateTime       *string            `protobuf:"bytes,6,req,name=createTime" json:"createTime,omitempty"`
	XXX_unrecognized []byte             `json:"-"`
}

func (m *SnapshotInfoProto) Reset()                    { *m = SnapshotInfoProto{} }
func (m *SnapshotInfoProto) String() string            { return proto.CompactTextString(m) }
func (*SnapshotInfoProto) ProtoMessage()               {}
func (*SnapshotInfoProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{33} }

func (m *SnapshotInfoProto) GetSnapshotName() string {
	if m != nil && m.SnapshotName != nil {
		return *m.SnapshotName
	}
	return ""
}

func (m *SnapshotInfoProto) GetSnapshotRoot() string {
	if m != nil && m.SnapshotRoot != nil {
		return *m.SnapshotRoot
	}
	return ""
}

func (m *SnapshotInfoProto) GetPermission() *FsPermissionProto {
	if m != nil {
		return m.Permission
	}
	return nil
}

func (m *SnapshotInfoProto) GetOwner() string {
	if m != nil && m.Owner != nil {
		return *m.Owner
	}
	return ""
}

func (m *SnapshotInfoProto) GetGroup() string {
	if m != nil && m.Group != nil {
		return *m.Group
	}
	return ""
}

func (m *SnapshotInfoProto) GetCreateTime() string {
	if m != nil && m.CreateTime != nil {
		return *m.CreateTime
	}
	return ""
}

// *
// Rolling upgrade status
type RollingUpgradeStatusProto struct {
	BlockPoolId      *string `protobuf:"bytes,1,req,name=blockPoolId" json:"blockPoolId,omitempty"`
	Finalized        *bool   `protobuf:"varint,2,opt,name=finalized,def=0" json:"finalized,omitempty"`
	XXX_unrecognized []byte  `json:"-"`
}

func (m *RollingUpgradeStatusProto) Reset()                    { *m = RollingUpgradeStatusProto{} }
func (m *RollingUpgradeStatusProto) String() string            { return proto.CompactTextString(m) }
func (*RollingUpgradeStatusProto) ProtoMessage()               {}
func (*RollingUpgradeStatusProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{34} }

const Default_RollingUpgradeStatusProto_Finalized bool = false

func (m *RollingUpgradeStatusProto) GetBlockPoolId() string {
	if m != nil && m.BlockPoolId != nil {
		return *m.BlockPoolId
	}
	return ""
}

func (m *RollingUpgradeStatusProto) GetFinalized() bool {
	if m != nil && m.Finalized != nil {
		return *m.Finalized
	}
	return Default_RollingUpgradeStatusProto_Finalized
}

// *
// A list of storage IDs.
type StorageUuidsProto struct {
	StorageUuids     []string `protobuf:"bytes,1,rep,name=storageUuids" json:"storageUuids,omitempty"`
	XXX_unrecognized []byte   `json:"-"`
}

func (m *StorageUuidsProto) Reset()                    { *m = StorageUuidsProto{} }
func (m *StorageUuidsProto) String() string            { return proto.CompactTextString(m) }
func (*StorageUuidsProto) ProtoMessage()               {}
func (*StorageUuidsProto) Descriptor() ([]byte, []int) { return fileDescriptor8, []int{35} }

func (m *StorageUuidsProto) GetStorageUuids() []string {
	if m != nil {
		return m.StorageUuids
	}
	return nil
}

func init() {
	proto.RegisterType((*ExtendedBlockProto)(nil), "hadoop.hdfs.ExtendedBlockProto")
	proto.RegisterType((*DatanodeIDProto)(nil), "hadoop.hdfs.DatanodeIDProto")
	proto.RegisterType((*DatanodeLocalInfoProto)(nil), "hadoop.hdfs.DatanodeLocalInfoProto")
	proto.RegisterType((*DatanodeInfosProto)(nil), "hadoop.hdfs.DatanodeInfosProto")
	proto.RegisterType((*DatanodeInfoProto)(nil), "hadoop.hdfs.DatanodeInfoProto")
	proto.RegisterType((*DatanodeStorageProto)(nil), "hadoop.hdfs.DatanodeStorageProto")
	proto.RegisterType((*StorageReportProto)(nil), "hadoop.hdfs.StorageReportProto")
	proto.RegisterType((*ContentSummaryProto)(nil), "hadoop.hdfs.ContentSummaryProto")
	proto.RegisterType((*QuotaUsageProto)(nil), "hadoop.hdfs.QuotaUsageProto")
	proto.RegisterType((*StorageTypeQuotaInfosProto)(nil), "hadoop.hdfs.StorageTypeQuotaInfosProto")
	proto.RegisterType((*StorageTypeQuotaInfoProto)(nil), "hadoop.hdfs.StorageTypeQuotaInfoProto")
	proto.RegisterType((*CorruptFileBlocksProto)(nil), "hadoop.hdfs.CorruptFileBlocksProto")
	proto.RegisterType((*FsPermissionProto)(nil), "hadoop.hdfs.FsPermissionProto")
	proto.RegisterType((*StorageTypesProto)(nil), "hadoop.hdfs.StorageTypesProto")
	proto.RegisterType((*BlockStoragePolicyProto)(nil), "hadoop.hdfs.BlockStoragePolicyProto")
	proto.RegisterType((*LocatedBlockProto)(nil), "hadoop.hdfs.LocatedBlockProto")
	proto.RegisterType((*DataEncryptionKeyProto)(nil), "hadoop.hdfs.DataEncryptionKeyProto")
	proto.RegisterType((*FileEncryptionInfoProto)(nil), "hadoop.hdfs.FileEncryptionInfoProto")
	proto.RegisterType((*PerFileEncryptionInfoProto)(nil), "hadoop.hdfs.PerFileEncryptionInfoProto")
	proto.RegisterType((*ZoneEncryptionInfoProto)(nil), "hadoop.hdfs.ZoneEncryptionInfoProto")
	proto.RegisterType((*CipherOptionProto)(nil), "hadoop.hdfs.CipherOptionProto")
	proto.RegisterType((*LocatedBlocksProto)(nil), "hadoop.hdfs.LocatedBlocksProto")
	proto.RegisterType((*ECSchemaOptionEntryProto)(nil), "hadoop.hdfs.ECSchemaOptionEntryProto")
	proto.RegisterType((*ECSchemaProto)(nil), "hadoop.hdfs.ECSchemaProto")
	proto.RegisterType((*ErasureCodingPolicyProto)(nil), "hadoop.hdfs.ErasureCodingPolicyProto")
	proto.RegisterType((*HdfsFileStatusProto)(nil), "hadoop.hdfs.HdfsFileStatusProto")
	proto.RegisterType((*FsServerDefaultsProto)(nil), "hadoop.hdfs.FsServerDefaultsProto")
	proto.RegisterType((*DirectoryListingProto)(nil), "hadoop.hdfs.DirectoryListingProto")
	proto.RegisterType((*SnapshottableDirectoryStatusProto)(nil), "hadoop.hdfs.SnapshottableDirectoryStatusProto")
	proto.RegisterType((*SnapshottableDirectoryListingProto)(nil), "hadoop.hdfs.SnapshottableDirectoryListingProto")
	proto.RegisterType((*SnapshotDiffReportEntryProto)(nil), "hadoop.hdfs.SnapshotDiffReportEntryProto")
	proto.RegisterType((*SnapshotDiffReportProto)(nil), "hadoop.hdfs.SnapshotDiffReportProto")
	proto.RegisterType((*BlockProto)(nil), "hadoop.hdfs.BlockProto")
	proto.RegisterType((*SnapshotInfoProto)(nil), "hadoop.hdfs.SnapshotInfoProto")
	proto.RegisterType((*RollingUpgradeStatusProto)(nil), "hadoop.hdfs.RollingUpgradeStatusProto")
	proto.RegisterType((*StorageUuidsProto)(nil), "hadoop.hdfs.StorageUuidsProto")
	proto.RegisterEnum("hadoop.hdfs.StorageTypeProto", StorageTypeProto_name, StorageTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.CipherSuiteProto", CipherSuiteProto_name, CipherSuiteProto_value)
	proto.RegisterEnum("hadoop.hdfs.CryptoProtocolVersionProto", CryptoProtocolVersionProto_name, CryptoProtocolVersionProto_value)
	proto.RegisterEnum("hadoop.hdfs.ChecksumTypeProto", ChecksumTypeProto_name, ChecksumTypeProto_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeInfoProto_AdminState", DatanodeInfoProto_AdminState_name, DatanodeInfoProto_AdminState_value)
	proto.RegisterEnum("hadoop.hdfs.DatanodeStorageProto_StorageState", DatanodeStorageProto_StorageState_name, DatanodeStorageProto_StorageState_value)
	proto.RegisterEnum("hadoop.hdfs.HdfsFileStatusProto_FileType", HdfsFileStatusProto_FileType_name, HdfsFileStatusProto_FileType_value)
}

func init() { proto.RegisterFile("hdfs.proto", fileDescriptor8) }

var fileDescriptor8 = []byte{
	// 2923 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xd4, 0x59, 0xcd, 0x73, 0x1b, 0xc7,
	0xb1, 0xf7, 0x2e, 0x00, 0x12, 0x68, 0x92, 0x20, 0x38, 0xfa, 0x82, 0x68, 0x59, 0xa6, 0xf7, 0x49,
	0x16, 0xad, 0x67, 0xb3, 0x6c, 0xea, 0x95, 0x5d, 0x4f, 0xf6, 0xf3, 0x0b, 0x09, 0x80, 0x16, 0x4a,
	0x10, 0x40, 0x0f, 0x48, 0xb9, 0xec, 0x4a, 0x0a, 0xb5, 0xdc, 0x1d, 0x10, 0x1b, 0x2e, 0x76, 0x36,
	0xbb, 0x0b, 0x5a, 0xf0, 0x29, 0xc7, 0x54, 0xa5, 0x92, 0x9c, 0x72, 0xcb, 0xc1, 0x55, 0xc9, 0x39,
	0xff, 0x86, 0xff, 0x87, 0x54, 0x2a, 0xc7, 0xe4, 0x9a, 0x43, 0xee, 0x49, 0x4d, 0xcf, 0xec, 0x17,
	0x3e, 0x44, 0xc5, 0x3e, 0xe5, 0x86, 0xfe, 0x4d, 0x77, 0xef, 0x74, 0xcf, 0xf4, 0xc7, 0x34, 0x00,
	0x46, 0xf6, 0x30, 0xdc, 0xf3, 0x03, 0x1e, 0x71, 0xb2, 0x36, 0x32, 0x6d, 0xce, 0xfd, 0x3d, 0x01,
	0x6d, 0x57, 0xfb, 0xcc, 0x9a, 0x04, 0x4e, 0x34, 0x95, 0x8b, 0xc6, 0x6f, 0x34, 0x20, 0xad, 0x17,
	0x11, 0xf3, 0x6c, 0x66, 0x1f, 0xba, 0xdc, 0xba, 0x38, 0x46, 0x99, 0x9b, 0xb0, 0xe2, 0x73, 0xee,
	0xb6, 0xed, 0xba, 0xb6, 0xa3, 0xef, 0x56, 0xa8, 0xa2, 0x48, 0x1d, 0x56, 0xcf, 0x04, 0x57, 0xdb,
	0xae, 0xeb, 0x3b, 0xfa, 0x6e, 0x91, 0xc6, 0x24, 0xd9, 0x85, 0xcd, 0x73, 0xe6, 0xb1, 0xc0, 0x8c,
	0x1c, 0xee, 0xf5, 0x23, 0x73, 0xec, 0xd7, 0x0b, 0xc8, 0x31, 0x0b, 0x93, 0x37, 0xa0, 0xec, 0x4d,
	0xc6, 0x87, 0xd3, 0x88, 0x85, 0xf5, 0xe2, 0x8e, 0xb6, 0x5b, 0x7c, 0xac, 0xbd, 0x4f, 0x13, 0xc8,
	0xf8, 0xab, 0x06, 0x9b, 0x4d, 0x33, 0x32, 0x3d, 0x6e, 0xb3, 0x76, 0x33, 0xd9, 0x8e, 0xe3, 0x1f,
	0xd8, 0x76, 0x10, 0x6f, 0x47, 0x52, 0x64, 0x1b, 0xca, 0x23, 0x1e, 0x46, 0x5d, 0x73, 0xcc, 0x70,
	0x3f, 0x15, 0x9a, 0xd0, 0xc4, 0x80, 0x75, 0x5b, 0xa9, 0x39, 0x9d, 0x38, 0x36, 0xee, 0xa6, 0x42,
	0x73, 0x98, 0x90, 0x7f, 0x31, 0x64, 0xc1, 0x31, 0x0f, 0xa2, 0x7a, 0x71, 0x47, 0xdf, 0xdd, 0xa0,
	0x09, 0x2d, 0xd6, 0x1c, 0x6f, 0xc8, 0x71, 0xad, 0x24, 0xd7, 0x62, 0x5a, 0xb8, 0xc1, 0xf1, 0x2d,
	0x5c, 0x5a, 0xc1, 0xa5, 0x98, 0x24, 0xef, 0x40, 0x55, 0x70, 0xa1, 0x97, 0x19, 0x32, 0xac, 0xee,
	0x68, 0xbb, 0x1b, 0xc2, 0xc4, 0x99, 0x05, 0xe3, 0xe7, 0x1a, 0xdc, 0x8c, 0x0d, 0xed, 0x70, 0xcb,
	0x74, 0xdb, 0x42, 0x3d, 0xda, 0xbb, 0x0b, 0x9b, 0x21, 0x1f, 0x46, 0x5f, 0x9b, 0x01, 0x7b, 0xce,
	0x82, 0xd0, 0xe1, 0x9e, 0x32, 0x7c, 0x16, 0x26, 0xf7, 0x60, 0xc3, 0xe2, 0xde, 0xd0, 0x39, 0x8f,
	0xf9, 0xa4, 0x1b, 0xf2, 0xa0, 0xf0, 0xdf, 0xc4, 0x8f, 0x9c, 0x31, 0x53, 0x67, 0xa2, 0x28, 0x83,
	0x02, 0x49, 0x5c, 0xed, 0x0d, 0x79, 0x28, 0xbf, 0xfe, 0x09, 0x54, 0x62, 0x2f, 0x85, 0x75, 0x6d,
	0xa7, 0xb0, 0xbb, 0xb6, 0x7f, 0x77, 0x2f, 0x73, 0x89, 0xf6, 0xb2, 0x32, 0x28, 0x42, 0x53, 0x01,
	0xe3, 0xef, 0x45, 0xd8, 0x9a, 0x63, 0x20, 0xef, 0x82, 0xee, 0xc8, 0xcb, 0xb4, 0xb6, 0x7f, 0x67,
	0xb1, 0x32, 0x79, 0xd6, 0x54, 0x77, 0x6c, 0x71, 0x45, 0x2c, 0xd3, 0x37, 0x2d, 0x27, 0x9a, 0xd6,
	0xf5, 0xe4, 0x8a, 0xc4, 0x10, 0x79, 0x1d, 0x56, 0xed, 0x61, 0x78, 0x1a, 0x32, 0x71, 0xaa, 0x6a,
	0x35, 0x46, 0xc8, 0x9b, 0x50, 0x09, 0xd8, 0xd8, 0x74, 0x3c, 0xc7, 0x3b, 0x4f, 0xef, 0x57, 0x8a,
	0x91, 0x07, 0xb0, 0x81, 0x97, 0xf6, 0x98, 0x73, 0x17, 0x75, 0x94, 0x62, 0xa6, 0x3c, 0x4e, 0xde,
	0x02, 0x70, 0xcd, 0x30, 0x3a, 0xf5, 0x6d, 0x33, 0x62, 0xf5, 0x95, 0x98, 0x2b, 0x03, 0x92, 0xfb,
	0xb0, 0xfe, 0xc2, 0x62, 0xce, 0x25, 0x0b, 0x1a, 0x7c, 0xe2, 0x65, 0x0e, 0x3b, 0x07, 0x8b, 0xbb,
	0xe4, 0x72, 0x0b, 0x63, 0xa0, 0x5e, 0xde, 0xd1, 0xc4, 0x3d, 0x8d, 0x69, 0xf2, 0x39, 0x80, 0x69,
	0x8f, 0x1d, 0x11, 0x1c, 0x11, 0xab, 0xc3, 0x8e, 0xb6, 0x5b, 0xdd, 0x7f, 0xe7, 0xe5, 0xee, 0xde,
	0x3b, 0x48, 0x04, 0x1e, 0xaf, 0x74, 0x7b, 0xf4, 0xd9, 0x41, 0x87, 0x66, 0x94, 0x08, 0x0b, 0x2d,
	0xd3, 0x1a, 0xb1, 0x46, 0xec, 0xc3, 0xb5, 0xc4, 0xc2, 0x1c, 0x2e, 0x7c, 0x85, 0x00, 0xba, 0x61,
	0x3d, 0xf1, 0x55, 0x82, 0x91, 0x47, 0x70, 0x2d, 0xb5, 0xf6, 0x19, 0xf7, 0x78, 0xc4, 0x3d, 0xc7,
	0xaa, 0x6f, 0xc4, 0xac, 0x8b, 0x56, 0xc5, 0x9d, 0x9c, 0xf8, 0xe7, 0x81, 0x69, 0xb3, 0x26, 0x17,
	0x4e, 0xaf, 0x57, 0xd1, 0xe4, 0x3c, 0x68, 0xb4, 0x01, 0x52, 0x33, 0x08, 0x80, 0x32, 0xa4, 0xf6,
	0x1a, 0x79, 0x1d, 0x6e, 0x35, 0x5b, 0x8d, 0xde, 0xb3, 0x67, 0xed, 0x7e, 0xbf, 0xdd, 0xeb, 0x0e,
	0xda, 0xdd, 0x63, 0xda, 0xfb, 0x8c, 0xb6, 0xfa, 0xfd, 0x9a, 0x46, 0x08, 0x54, 0xb3, 0x8b, 0xad,
	0x66, 0x4d, 0x37, 0xfe, 0xa9, 0xc1, 0xf5, 0xd8, 0x49, 0xfd, 0x88, 0x07, 0xe6, 0x39, 0x93, 0xb7,
	0x6e, 0x07, 0xd6, 0x42, 0x49, 0x63, 0x0a, 0x90, 0x31, 0x94, 0x85, 0x48, 0x07, 0x4a, 0x21, 0x3a,
	0x5e, 0x47, 0xc7, 0xef, 0x2d, 0x74, 0x7c, 0x56, 0xe7, 0x9e, 0x22, 0xf2, 0xde, 0x97, 0x4a, 0x48,
	0x2b, 0xf9, 0xde, 0xc9, 0xd4, 0x67, 0x78, 0x39, 0xab, 0xfb, 0x6f, 0xe4, 0x74, 0xf6, 0xd3, 0x75,
	0xd4, 0xf7, 0xb8, 0xd8, 0x6c, 0xf7, 0x9f, 0xd2, 0xac, 0x9c, 0xf1, 0x3e, 0xac, 0x67, 0xbf, 0x92,
	0x73, 0xce, 0x75, 0xa8, 0xd1, 0xd6, 0x41, 0x73, 0xd0, 0xeb, 0x76, 0xbe, 0x1c, 0xf4, 0x9f, 0x1c,
	0xd0, 0x56, 0xb3, 0xa6, 0x19, 0xbf, 0xd3, 0x81, 0x28, 0x11, 0xca, 0x7c, 0x1e, 0x44, 0xd2, 0xfe,
	0x7b, 0x0b, 0xec, 0x3f, 0xd4, 0xeb, 0x5a, 0xde, 0x07, 0x6f, 0xc0, 0xca, 0xd0, 0x74, 0x5c, 0x66,
	0xa3, 0x13, 0xca, 0x8f, 0x4b, 0x43, 0xd3, 0x0d, 0x19, 0x55, 0x60, 0x2e, 0x18, 0x0b, 0x2f, 0x0d,
	0xc6, 0xe2, 0xcb, 0x83, 0xb1, 0xf4, 0x2a, 0xc1, 0xb8, 0xb2, 0x24, 0x18, 0x3f, 0x86, 0x55, 0xb5,
	0x67, 0x0c, 0xb2, 0xb5, 0xfd, 0xb7, 0xae, 0x3c, 0x2a, 0x1a, 0x4b, 0x18, 0xdf, 0xea, 0x70, 0xad,
	0xc1, 0xbd, 0x88, 0x79, 0x51, 0x7f, 0x32, 0x1e, 0x9b, 0xc1, 0x34, 0xa9, 0x2b, 0x2e, 0xf3, 0xce,
	0xa3, 0x11, 0xba, 0xa6, 0x48, 0x15, 0x45, 0xee, 0x40, 0x65, 0xe8, 0xb8, 0x4c, 0xc6, 0xb4, 0x2c,
	0x74, 0x29, 0x40, 0xde, 0x86, 0xaa, 0xed, 0x04, 0xcc, 0x8a, 0x78, 0x30, 0x95, 0x2c, 0x32, 0xab,
	0xce, 0xa0, 0xe4, 0x3a, 0x94, 0x7e, 0x36, 0xe1, 0x91, 0x89, 0xa5, 0xa5, 0x48, 0x25, 0x21, 0xa2,
	0x23, 0xf4, 0x4d, 0x8b, 0x35, 0xb8, 0x17, 0x4e, 0xc6, 0x98, 0x7e, 0xc4, 0x6a, 0x1e, 0x24, 0x77,
	0x01, 0x10, 0xf8, 0x1c, 0x15, 0xac, 0x20, 0x4b, 0x06, 0x21, 0x3d, 0xa8, 0x46, 0x53, 0x5f, 0x12,
	0x98, 0xba, 0x95, 0x57, 0x1e, 0x2c, 0xbb, 0x6c, 0x29, 0xa7, 0xf4, 0xcd, 0x8c, 0xb8, 0xf1, 0x0f,
	0x0d, 0x36, 0x91, 0x3c, 0x0d, 0x93, 0xf0, 0xf9, 0x1f, 0xb8, 0x21, 0xac, 0x3e, 0xf0, 0xec, 0x66,
	0xde, 0x5e, 0xe9, 0xad, 0xc5, 0x8b, 0xa9, 0xd9, 0xfa, 0x4b, 0xcd, 0x2e, 0x5c, 0x6d, 0x76, 0xf1,
	0x15, 0xcc, 0x2e, 0xfd, 0x30, 0xb3, 0x7f, 0x0a, 0xdb, 0xcb, 0xb9, 0x49, 0x07, 0x36, 0x72, 0xfc,
	0xaa, 0x1a, 0xbe, 0x7d, 0xe5, 0xd7, 0xe4, 0xc7, 0xf2, 0xc2, 0xa2, 0xe0, 0xdf, 0x5e, 0xca, 0x4c,
	0x3e, 0x80, 0xa2, 0x60, 0x47, 0xdf, 0x5e, 0x95, 0x34, 0x28, 0xb2, 0x2e, 0xf1, 0xf4, 0x36, 0x94,
	0xad, 0xbc, 0x93, 0x13, 0xda, 0x38, 0x82, 0x9b, 0x0d, 0x1e, 0x04, 0x13, 0x3f, 0x3a, 0x72, 0x5c,
	0x86, 0x0d, 0x9f, 0x32, 0xf5, 0x3a, 0x94, 0xc4, 0x71, 0xca, 0x82, 0x5f, 0xa1, 0x92, 0x10, 0x01,
	0x62, 0x71, 0x7e, 0xe1, 0xc4, 0xed, 0x95, 0xa2, 0x8c, 0x07, 0xb0, 0x75, 0x14, 0x1e, 0xb3, 0x60,
	0xec, 0x84, 0xa2, 0xc1, 0x90, 0x2a, 0x08, 0x14, 0x7d, 0x16, 0x8c, 0xd1, 0x82, 0x0d, 0x8a, 0xbf,
	0x8d, 0xe7, 0xb0, 0x95, 0xd9, 0xbc, 0xfa, 0xd6, 0x01, 0xac, 0x67, 0xd2, 0x9d, 0xfc, 0xe4, 0x95,
	0x26, 0xe7, 0x44, 0x8c, 0xef, 0x74, 0xb8, 0x85, 0xdb, 0x8f, 0x03, 0x9e, 0xbb, 0x8e, 0xa5, 0xa2,
	0x7a, 0x1b, 0xca, 0x3e, 0x92, 0xaa, 0x7d, 0xdd, 0xa0, 0x09, 0x2d, 0xf6, 0xe8, 0xa5, 0xdd, 0x22,
	0xfe, 0x26, 0x47, 0x50, 0xb5, 0x02, 0x86, 0xd5, 0x58, 0xaa, 0x41, 0xb7, 0xcd, 0x36, 0x3d, 0x73,
	0x66, 0xd0, 0x19, 0x29, 0xf2, 0x1c, 0x6e, 0xc6, 0xc8, 0x91, 0xe9, 0xba, 0x67, 0xa6, 0x48, 0x5f,
	0xa8, 0xaf, 0x88, 0x97, 0xf4, 0x2a, 0x7d, 0x4b, 0xa4, 0xc9, 0x8f, 0xe1, 0x76, 0xc0, 0x7c, 0xd7,
	0xb1, 0x16, 0xa9, 0x2e, 0xbd, 0x92, 0xea, 0xe5, 0x0a, 0x8c, 0xef, 0x0a, 0xb0, 0x25, 0xda, 0xcf,
	0x28, 0xf7, 0x00, 0x78, 0x0f, 0xb4, 0x33, 0xd5, 0xae, 0xbd, 0x99, 0xd3, 0x3d, 0xff, 0x58, 0xa0,
	0xda, 0x99, 0xb8, 0x27, 0x7c, 0x38, 0x0c, 0x59, 0x9c, 0x2d, 0x15, 0x45, 0xf6, 0xa1, 0xe8, 0x72,
	0x2b, 0xac, 0x17, 0x5e, 0xa9, 0x8b, 0x44, 0x5e, 0xd1, 0x5c, 0x5b, 0xf2, 0x8e, 0x62, 0x02, 0x28,
	0xd3, 0x98, 0x24, 0xff, 0x0b, 0x80, 0x45, 0xe1, 0x84, 0x5f, 0x30, 0x0f, 0xf3, 0xe6, 0xda, 0xfe,
	0xed, 0x58, 0xa7, 0xc5, 0xc7, 0x63, 0xee, 0xed, 0xe1, 0x9a, 0x54, 0x97, 0x61, 0x26, 0x77, 0xa1,
	0xec, 0x84, 0x0d, 0xd1, 0xd7, 0x88, 0x12, 0x53, 0xd8, 0x2d, 0x1f, 0xea, 0x35, 0x8d, 0x26, 0xd8,
	0xdc, 0x95, 0x5c, 0xfd, 0xb7, 0xaf, 0x24, 0xe6, 0x2e, 0x49, 0xb7, 0x9b, 0x61, 0xbd, 0x8c, 0x61,
	0x94, 0x41, 0xc4, 0x83, 0x44, 0x3e, 0x96, 0x3c, 0xdb, 0xb1, 0x58, 0x58, 0xaf, 0xec, 0x68, 0xbb,
	0xeb, 0x34, 0x87, 0x91, 0x8f, 0x61, 0x2d, 0xdd, 0x74, 0x58, 0x07, 0x74, 0xdb, 0x4b, 0x4c, 0xcc,
	0x72, 0x1b, 0x7f, 0x51, 0x0f, 0x8a, 0x96, 0x67, 0x05, 0x53, 0x5f, 0x1c, 0xf5, 0x53, 0x36, 0x4d,
	0xa2, 0xfb, 0x82, 0xa5, 0xf1, 0x20, 0x09, 0xd1, 0x1e, 0x25, 0x45, 0x56, 0xbd, 0xe8, 0x2a, 0x34,
	0x0b, 0x09, 0x39, 0x8f, 0x7b, 0x96, 0x7c, 0x37, 0xac, 0x53, 0x49, 0x88, 0x5c, 0xce, 0xb2, 0xdf,
	0xc0, 0x73, 0x5a, 0xa7, 0x79, 0x50, 0xf8, 0x83, 0xbd, 0xf0, 0x9d, 0x60, 0xda, 0x14, 0xfd, 0x95,
	0xac, 0x72, 0x19, 0x84, 0xbc, 0x0f, 0xd7, 0x52, 0x81, 0x03, 0xf7, 0x9c, 0x07, 0x4e, 0x34, 0x1a,
	0x63, 0x03, 0x50, 0xa1, 0x8b, 0x96, 0x8c, 0xdf, 0xea, 0x70, 0x4b, 0xe4, 0xad, 0xd4, 0xc0, 0x34,
	0x7d, 0x3e, 0x82, 0x52, 0x38, 0x71, 0xa2, 0xc5, 0xf9, 0xb3, 0xe1, 0xf8, 0x23, 0x16, 0xf4, 0xc5,
	0xba, 0xf4, 0x9b, 0xe4, 0x25, 0x3f, 0x81, 0x1b, 0xa8, 0x49, 0xea, 0xb0, 0xb8, 0x9b, 0x7d, 0x45,
	0x55, 0x67, 0xaa, 0x4a, 0x63, 0x11, 0xa7, 0x54, 0xb7, 0x58, 0x0b, 0xa9, 0x41, 0xe1, 0x82, 0x4d,
	0x95, 0xef, 0xc4, 0x4f, 0x52, 0x05, 0xdd, 0xb9, 0x54, 0xee, 0xd2, 0x9d, 0x4b, 0x71, 0xd7, 0x2f,
	0xd8, 0x14, 0xdf, 0xaf, 0x25, 0xf4, 0x7e, 0x4c, 0x92, 0x87, 0x50, 0x63, 0xdf, 0x3c, 0x65, 0x53,
	0xa5, 0x0b, 0x59, 0x56, 0x90, 0x65, 0x0e, 0x17, 0x45, 0xec, 0x98, 0x05, 0xcb, 0x3c, 0xa3, 0x76,
	0xa1, 0xcd, 0xee, 0x42, 0x4f, 0x76, 0xb1, 0xe8, 0x5b, 0x85, 0x25, 0xdf, 0xfa, 0x4e, 0x83, 0x5b,
	0x5f, 0x71, 0xef, 0x3f, 0xe6, 0x0c, 0x32, 0x1e, 0x2e, 0xe4, 0x3c, 0x6c, 0x7c, 0xab, 0xc1, 0x96,
	0xdc, 0x54, 0x0f, 0xed, 0xf8, 0x01, 0x36, 0x5c, 0x87, 0x92, 0x83, 0x81, 0xa0, 0x63, 0x4c, 0x4b,
	0x42, 0xd4, 0x1a, 0xc7, 0x6b, 0x5f, 0x62, 0xd3, 0xbc, 0x4e, 0xf1, 0x37, 0x26, 0xca, 0x49, 0x24,
	0x63, 0x46, 0xa0, 0x8a, 0x12, 0x1a, 0xf8, 0x24, 0x6a, 0x5f, 0x62, 0x3e, 0x5f, 0xa7, 0x92, 0x30,
	0x7e, 0x5f, 0x00, 0x92, 0xcd, 0xcd, 0xaa, 0x7e, 0xde, 0x05, 0x10, 0xe5, 0xb9, 0x93, 0x6d, 0x5d,
	0x33, 0x08, 0xf9, 0x10, 0x56, 0x30, 0x88, 0xc3, 0xba, 0xbe, 0x20, 0xef, 0xce, 0x25, 0x7b, 0xaa,
	0xb8, 0xc9, 0xbb, 0xb0, 0x35, 0xf1, 0x6c, 0xf1, 0x68, 0xf5, 0xc2, 0x28, 0x98, 0x58, 0xf8, 0x5e,
	0x2d, 0x60, 0x0e, 0x9e, 0x5f, 0x20, 0x9f, 0x40, 0x45, 0xbc, 0xfe, 0x50, 0xcf, 0xc2, 0x0a, 0x37,
	0xff, 0xa1, 0x54, 0x40, 0x44, 0xbf, 0x13, 0x76, 0x62, 0xb2, 0xc1, 0xc7, 0xbe, 0xcb, 0x54, 0x9a,
	0x28, 0xd3, 0x45, 0x4b, 0xe4, 0x04, 0xc8, 0x70, 0xee, 0x8a, 0x63, 0xba, 0x58, 0xdb, 0xbf, 0x97,
	0xfb, 0xf0, 0x92, 0x48, 0xa0, 0x0b, 0xe4, 0xc9, 0x01, 0x94, 0x99, 0xa5, 0x6a, 0xa9, 0x6c, 0xa1,
	0xef, 0xe7, 0xeb, 0x5d, 0x60, 0x86, 0x93, 0x80, 0x35, 0xb8, 0xed, 0x78, 0xe7, 0x99, 0x2e, 0x83,
	0x26, 0x62, 0xc6, 0x21, 0xd4, 0x5b, 0x8d, 0xbe, 0x35, 0x62, 0x63, 0x53, 0xde, 0xa4, 0x96, 0x17,
	0xc5, 0x2f, 0x8c, 0x4c, 0xf0, 0x55, 0x64, 0xf0, 0x5d, 0x87, 0xd2, 0xa5, 0xe9, 0x4e, 0xe2, 0x16,
	0x44, 0x12, 0xc6, 0x1f, 0x35, 0xd8, 0x88, 0x95, 0x48, 0xc9, 0x3b, 0x50, 0xb1, 0xb8, 0xcd, 0x2c,
	0xbc, 0xba, 0x52, 0x3e, 0x05, 0xc4, 0xaa, 0x6d, 0x46, 0xe6, 0xa9, 0xe7, 0x44, 0x21, 0x6a, 0xda,
	0xa0, 0x29, 0x20, 0x12, 0xbb, 0x6f, 0x06, 0x4e, 0x34, 0x95, 0xeb, 0x05, 0x5c, 0xcf, 0x42, 0xe4,
	0xff, 0x61, 0x95, 0xe3, 0x5e, 0xc3, 0x7a, 0x11, 0xef, 0xc8, 0x8c, 0xd5, 0x4b, 0xec, 0xa1, 0xb1,
	0x94, 0xf1, 0x6b, 0x0d, 0xea, 0xcb, 0x7c, 0x93, 0x74, 0x59, 0x5a, 0xa6, 0xcb, 0xda, 0x87, 0x95,
	0x10, 0x75, 0xe2, 0x76, 0xd7, 0xf6, 0xb7, 0x17, 0x7e, 0x50, 0x5d, 0x48, 0xc9, 0x89, 0xad, 0x2c,
	0x73, 0xdd, 0xbe, 0xf3, 0x0d, 0x53, 0x46, 0x24, 0x34, 0x26, 0x31, 0x5b, 0x4d, 0xed, 0x74, 0xc7,
	0x36, 0xfe, 0xb0, 0x02, 0xd7, 0x9e, 0xd8, 0xc3, 0x50, 0x1c, 0xbe, 0x78, 0x36, 0x4f, 0x54, 0xb0,
	0xb4, 0xa0, 0x2c, 0x8e, 0xfd, 0x24, 0xed, 0xad, 0xf3, 0xd3, 0x95, 0x05, 0x32, 0x78, 0x81, 0x84,
	0x00, 0x4d, 0x44, 0xb1, 0xb9, 0x35, 0xa3, 0x91, 0xca, 0x9a, 0xf8, 0x3b, 0xf3, 0x7c, 0x2c, 0xe4,
	0x9e, 0x8f, 0x9f, 0x02, 0xf8, 0x49, 0x6f, 0x8c, 0x5b, 0x9c, 0x0d, 0x8d, 0xb9, 0xe6, 0x99, 0x66,
	0x24, 0x30, 0x19, 0x7c, 0xed, 0xb1, 0x40, 0xd5, 0x04, 0x49, 0x08, 0xf4, 0x3c, 0xe0, 0x13, 0x5f,
	0x95, 0x01, 0x49, 0x90, 0xff, 0x86, 0xad, 0x31, 0xb7, 0x9d, 0xa1, 0x6a, 0xee, 0x06, 0x38, 0xe5,
	0x5b, 0xc5, 0xed, 0xd4, 0xb2, 0x0b, 0x27, 0xce, 0x98, 0x91, 0x37, 0x61, 0xcd, 0xb4, 0x2c, 0x16,
	0x86, 0x92, 0xad, 0x2c, 0x33, 0x87, 0x84, 0x90, 0xa1, 0x0e, 0xab, 0xe1, 0x74, 0xec, 0x3a, 0xde,
	0x85, 0x6a, 0x4f, 0x62, 0x92, 0xec, 0xc1, 0x16, 0x66, 0x89, 0x41, 0xa6, 0x93, 0xc4, 0x69, 0x15,
	0x8e, 0xbb, 0x6a, 0xb8, 0x46, 0xd3, 0x25, 0xf1, 0xf2, 0x97, 0x59, 0x45, 0x9c, 0x5d, 0x32, 0x7f,
	0x4a, 0x31, 0xf2, 0x7f, 0x50, 0x89, 0x67, 0x60, 0x21, 0xce, 0x9e, 0x66, 0x3b, 0xcd, 0xf9, 0xc4,
	0x47, 0x53, 0x09, 0x72, 0x1b, 0x56, 0xc4, 0xd9, 0xb4, 0xed, 0x74, 0x18, 0xa5, 0x00, 0x72, 0x0f,
	0xd6, 0xac, 0x91, 0xe3, 0xda, 0x01, 0xf3, 0xba, 0x93, 0x31, 0x4e, 0x9f, 0x4a, 0x8f, 0xf5, 0xf7,
	0x3e, 0xa0, 0x59, 0x78, 0x49, 0x3a, 0xd9, 0xfc, 0x81, 0xe9, 0xe4, 0x01, 0x6c, 0x84, 0xd9, 0x17,
	0x49, 0xbd, 0x16, 0xbb, 0x28, 0x8f, 0xe7, 0xf2, 0xce, 0xd6, 0xf7, 0xcb, 0x3b, 0x8f, 0xa0, 0x1c,
	0x5f, 0x54, 0x02, 0xb0, 0xd2, 0xee, 0x0f, 0x9a, 0x6d, 0x5a, 0xd3, 0xc8, 0x1a, 0xac, 0xb6, 0xfb,
	0x83, 0xa3, 0x76, 0xa7, 0x55, 0xd3, 0x49, 0x15, 0xa0, 0xdd, 0x1f, 0xf4, 0xbf, 0x7c, 0xd6, 0x69,
	0x77, 0x9f, 0xd6, 0x0a, 0xc6, 0x2f, 0x0b, 0x70, 0xe3, 0x28, 0xec, 0xb3, 0xe0, 0x92, 0x05, 0x4d,
	0x36, 0x34, 0x27, 0x6e, 0x14, 0x26, 0x09, 0x07, 0x4f, 0x07, 0xa3, 0x4d, 0x16, 0x95, 0x14, 0x10,
	0x3d, 0xc2, 0xd9, 0x34, 0x62, 0xe2, 0xde, 0x36, 0x46, 0xcc, 0xba, 0x08, 0x27, 0x63, 0x95, 0x77,
	0xe6, 0x70, 0xb2, 0x0b, 0x9b, 0x5f, 0x07, 0xa2, 0x46, 0x9a, 0xd6, 0x05, 0x8b, 0x32, 0xd1, 0x3b,
	0x0b, 0x8b, 0x44, 0x95, 0xbd, 0x4f, 0x32, 0x9a, 0xb3, 0x10, 0x79, 0x1b, 0xaa, 0xc2, 0xcd, 0x87,
	0x93, 0xe1, 0x90, 0x05, 0xa8, 0x4a, 0x0e, 0xe3, 0x67, 0x50, 0xf2, 0x51, 0xd2, 0x4d, 0x8a, 0x16,
	0xf8, 0x24, 0x30, 0xbd, 0x70, 0xc8, 0x02, 0x2c, 0x0f, 0xc9, 0x44, 0x6b, 0x11, 0x87, 0x38, 0xb1,
	0x28, 0x30, 0xc3, 0x51, 0xdb, 0x8b, 0x58, 0x70, 0x69, 0xba, 0x58, 0x05, 0xe4, 0x04, 0x2a, 0x87,
	0x13, 0x0a, 0xeb, 0x96, 0xb2, 0x10, 0x93, 0x49, 0x19, 0xa7, 0x7b, 0xf9, 0xb8, 0x6e, 0x64, 0x18,
	0xe4, 0x78, 0xaf, 0xda, 0x78, 0xd2, 0x6a, 0x3c, 0xed, 0x9f, 0x3e, 0x1b, 0x34, 0x68, 0xe3, 0xd1,
	0x3e, 0xcd, 0xe9, 0x30, 0x7e, 0xa5, 0xc1, 0x8d, 0x64, 0x7c, 0xd2, 0x71, 0xc2, 0x48, 0x1c, 0x36,
	0x9e, 0xc6, 0x13, 0xa8, 0xfa, 0x66, 0x10, 0x39, 0xa6, 0xab, 0x60, 0x35, 0x7b, 0xd8, 0xb9, 0x2a,
	0x79, 0xd1, 0x19, 0x39, 0x71, 0x72, 0xc9, 0xbc, 0x4d, 0x64, 0x72, 0x87, 0xc5, 0x15, 0x63, 0x0e,
	0x37, 0xfe, 0xac, 0xc1, 0x5b, 0x7d, 0xcf, 0xf4, 0xc3, 0x11, 0x8f, 0x22, 0xf3, 0xcc, 0x65, 0xc9,
	0xe6, 0xb2, 0x29, 0xf5, 0x53, 0xa8, 0xd8, 0x4e, 0x20, 0x11, 0xf5, 0x48, 0xbc, 0x7a, 0x5b, 0xa9,
	0x08, 0xb9, 0x0f, 0xd5, 0x50, 0x7d, 0x64, 0x90, 0x0e, 0x30, 0x36, 0xe8, 0x46, 0x8c, 0xca, 0x61,
	0xcf, 0x03, 0xd8, 0x4c, 0xd8, 0xbc, 0xc9, 0xf8, 0x8c, 0x05, 0xea, 0x1a, 0x25, 0xd2, 0x5d, 0x44,
	0x05, 0xa3, 0x6f, 0x06, 0xcc, 0x8b, 0x06, 0xc3, 0x89, 0xeb, 0x62, 0x9a, 0x96, 0x2d, 0x76, 0x55,
	0xc2, 0x47, 0x0a, 0x15, 0x45, 0xcb, 0x58, 0x6c, 0x5e, 0xce, 0xf7, 0x23, 0xb8, 0x15, 0xce, 0x70,
	0xe5, 0x0f, 0x21, 0x3f, 0x26, 0xbe, 0xd2, 0x61, 0x74, 0x99, 0x3a, 0xe3, 0x17, 0x1a, 0xdc, 0x89,
	0xc5, 0x9b, 0xce, 0x70, 0x28, 0x87, 0xb7, 0x99, 0xfe, 0x61, 0x1b, 0xca, 0x89, 0x4d, 0xb2, 0x83,
	0x4f, 0x68, 0xd1, 0xae, 0x65, 0x33, 0x7c, 0xc7, 0x3c, 0x63, 0xae, 0xea, 0x2a, 0xe6, 0x17, 0x44,
	0xd3, 0x18, 0x99, 0xc1, 0x39, 0x8b, 0x8e, 0x4d, 0x2c, 0x58, 0x22, 0xbb, 0x67, 0x10, 0xe3, 0x4f,
	0x1a, 0xdc, 0x9a, 0xdf, 0x8a, 0xdc, 0x85, 0x01, 0xeb, 0xb1, 0x05, 0x94, 0xf3, 0x48, 0xd5, 0xf5,
	0x1c, 0x26, 0x78, 0x86, 0x01, 0x1f, 0xc7, 0x2a, 0xd4, 0x46, 0x72, 0x18, 0xee, 0x81, 0x27, 0x1c,
	0xb2, 0x1f, 0xcf, 0x20, 0xe4, 0x0b, 0xd8, 0xb2, 0x73, 0x5e, 0x70, 0x58, 0xdc, 0x9f, 0xbc, 0xb3,
	0xd0, 0xe5, 0x8b, 0x7c, 0x46, 0xe7, 0x75, 0x18, 0x26, 0x40, 0x66, 0xb8, 0x91, 0xf9, 0x17, 0x53,
	0xcb, 0xff, 0x8b, 0xb9, 0x0d, 0xe5, 0x73, 0xa6, 0xfe, 0xbe, 0x94, 0x93, 0x8c, 0x84, 0xce, 0xfd,
	0x6f, 0x59, 0x98, 0xff, 0xdf, 0xf2, 0x6f, 0x1a, 0x6c, 0xc5, 0xdb, 0x4a, 0x9f, 0x44, 0x19, 0xcf,
	0x65, 0x1a, 0xb9, 0x1c, 0x36, 0xe7, 0x5d, 0x7d, 0x81, 0x77, 0xf3, 0x2d, 0x45, 0xe1, 0xfb, 0xb7,
	0x14, 0xc5, 0x85, 0x2d, 0x45, 0x29, 0xdb, 0x52, 0xdc, 0x05, 0xc0, 0x49, 0x14, 0x13, 0x2d, 0x81,
	0xea, 0x36, 0x32, 0x88, 0x71, 0x06, 0xb7, 0x29, 0x77, 0x5d, 0xc7, 0x3b, 0x3f, 0x95, 0xff, 0xe8,
	0x64, 0x73, 0xc3, 0xcc, 0x4c, 0x41, 0x9b, 0x9f, 0x29, 0xfc, 0x17, 0x54, 0x86, 0x8e, 0x67, 0xba,
	0xce, 0x37, 0xb3, 0xff, 0x38, 0xa4, 0xb8, 0xf1, 0x51, 0x32, 0x37, 0x3c, 0x9d, 0x38, 0x76, 0x98,
	0x3a, 0x33, 0x03, 0xaa, 0x51, 0x65, 0x0e, 0x7b, 0xf8, 0x23, 0xa8, 0xcd, 0xce, 0x69, 0x48, 0x19,
	0xf0, 0x4f, 0x96, 0x9a, 0x46, 0x56, 0xa1, 0xd0, 0xef, 0x37, 0x6b, 0xba, 0xa8, 0x91, 0x07, 0xb4,
	0xf1, 0xa4, 0xfd, 0xbc, 0x55, 0x2b, 0x90, 0x75, 0x28, 0xd3, 0x83, 0x67, 0x03, 0xe4, 0x29, 0x3e,
	0xfc, 0x10, 0x6a, 0xb3, 0xef, 0x3c, 0xc1, 0x7e, 0xda, 0x7d, 0xda, 0xed, 0x7d, 0xd1, 0xad, 0x69,
	0xe4, 0x06, 0x6c, 0x1d, 0xb4, 0xfa, 0x83, 0xc6, 0x09, 0x1d, 0x74, 0x7b, 0xc7, 0x07, 0xcd, 0x66,
	0xbb, 0xfb, 0x59, 0x4d, 0x7f, 0x78, 0x0c, 0xdb, 0xcb, 0x9f, 0xa7, 0xe4, 0x0e, 0xd4, 0x95, 0x86,
	0xc1, 0x31, 0xed, 0x9d, 0xf4, 0x1a, 0xbd, 0xce, 0xe0, 0x79, 0x8b, 0xf6, 0xdb, 0x3d, 0xa1, 0xf2,
	0x3a, 0xd4, 0x5a, 0xdd, 0x06, 0xfd, 0xf2, 0xf8, 0xa4, 0xdd, 0xeb, 0x0e, 0xbe, 0xea, 0x75, 0x5b,
	0xfd, 0x9a, 0xfe, 0xb0, 0x07, 0x5b, 0x73, 0x05, 0x85, 0x6c, 0xc1, 0x46, 0x52, 0x52, 0xba, 0xa7,
	0x9d, 0x4e, 0xed, 0x35, 0x42, 0x60, 0xa6, 0xca, 0xd4, 0x34, 0x72, 0x0d, 0x36, 0xf3, 0x58, 0xa3,
	0xa6, 0x1f, 0x7e, 0x08, 0xf7, 0x79, 0x70, 0xbe, 0x67, 0xfa, 0xa6, 0x35, 0x62, 0xb9, 0xdb, 0xe3,
	0xab, 0x3d, 0xcb, 0x1f, 0x87, 0x20, 0x32, 0x38, 0x7e, 0x2f, 0xfc, 0x56, 0xd3, 0xfe, 0x15, 0x00,
	0x00, 0xff, 0xff, 0xd4, 0x8c, 0x02, 0x21, 0x4f, 0x20, 0x00, 0x00,
}
