name: Validate Pull Request

on:
  pull_request:
    types:
      - opened
      - synchronize
      - edited
      - reopened
    branches:    
      - 'main'
      - 'release-**'
    # paths-ignore:
    #   - 'docs/**'
    #   - '.github/'
    #   - 'CHANGELOG/'
    #   - 'charts/'
    #   - 'manifests/'
    #   - 'sample-docker-templates/'
  
jobs:
  validate-PR-issue:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: read
      pull-requests: write

    steps:
    - name: Checkout repository
      uses: actions/checkout@v2
      with:
        ref: ${{ github.event.pull_request.head.sha }}
        fetch-depth: 0


    - name: Validate Issue Reference
      env:
        GITHUB_TOKEN: ${{ github.token }}
        GH_TOKEN: ${{ github.token }}
        PR_BODY: ${{ github.event.pull_request.body }}
        url: ${{ github.event.pull_request.url }}
        PRNUM: ${{ github.event.pull_request.number }}
        TITLE: ${{ github.event.pull_request.title }}
      run: |
        set -x
        # Skip validation for documentation or chore PRs
        if [[ "$TITLE" =~ ^(doc:|docs:|chore:|misc:) ]]; then
          echo "Skipping validation for doc/docs/chore/misc PR."
          echo "PR NUMBER-: $PRNUM "
          gh pr edit $PRNUM --remove-label "PR:Issue-verification-failed"
          gh pr edit $PRNUM --add-label "PR:Ready-to-Review"
          exit 0
        fi
    
        # Define all issue matching patterns
        patterns=(
          "((Fixes|Resolves) #[0-9]+)" 
          "((Fixes|Resolves) https://github.com/devtron-labs/devtron/issues/[0-9]+)" 
          "((Fixes|Resolves) devtron-labs/devtron#[0-9]+)"
          "(Fixes|Resolves):?\\s+\\[#([0-9]+)\\]" 
          "((Fixes|Resolves):? #devtron-labs/devops-sprint/issues/[0-9]+)"
          "((Fixes|Resolves):? #devtron-labs/sprint-tasks/issues/[0-9]+)" 
          "((Fixes|Resolves) https://github.com/devtron-labs/devops-sprint/issues/[0-9]+)"
          "((Fixes|Resolves) https://github.com/devtron-labs/sprint-tasks/issues/[0-9]+)"
        )
    
        # Extract issue number and repo from PR body
        extract_issue_number() {
          local pattern="$1"  # Get the pattern as the first argument to the function

          # Check if PR_BODY matches the provided pattern using Bash's =~ regex operator
          if [[ "$PR_BODY" =~ $pattern ]]; then
            echo "matched for this pattern $pattern"
            
            issue_num=$(echo "$PR_BODY" | grep -oE "$pattern" | grep -oE "[0-9]+")

            # Extract the repository name (e.g., devtron-labs/devtron) from PR_BODY using grep
            repo=$(echo "$PR_BODY" | grep -oE "devtron-labs/[a-zA-Z0-9_-]+")
            echo "Extracted issue number: $issue_num from repo: $repo"

            return 0  # Return success
          else
            echo "No match for the pattern $pattern"
          fi
          return 1  # Return failure if no match
        }
    
        issue_num=""
        repo="devtron-labs/devtron"  # Default repo
        for pattern in "${patterns[@]}"; do
          echo "Now checking for $pattern"
          extract_issue_number "$pattern" && break
        done
    
        if [[ -z "$issue_num" ]]; then
          echo "No valid issue number found."
          gh pr edit $PRNUM --add-label "PR:Issue-verification-failed"
          gh pr edit $PRNUM --remove-label "PR:Ready-to-Review"
          exit 1
        fi
    
        # Form the issue API URL dynamically
        issue_api_url="https://api.github.com/repos/$repo/issues/$issue_num"
        echo "API URL: $issue_api_url"
    
        # Check if the issue exists in the private repo
        response_code=$(curl -s -o /dev/null -w "%{http_code}" \
          --header "authorization: Bearer ${{ secrets.GH_PR_VALIDATOR_TOKEN }}" \
          "$issue_api_url")
          
        if [[ "$response_code" -eq 200 ]]; then
          echo "Issue #$issue_num is valid and exists in $repo."

          # Fetch the current state of the issue (open/closed) from the private repository.
          issue_status=$(curl -s \
            --header "authorization: Bearer ${{ secrets.GH_PR_VALIDATOR_TOKEN }}" \
            "$issue_api_url" | jq '.state'|tr -d \")
          # Check if the issue is still open.
          if [[ "$issue_status" == open ]]; then
            echo "Issue #$issue_num is opened."
            # Remove the 'Issue-verification-failed' label (if present) and add 'Ready-to-Review'.
            gh pr edit $PRNUM --remove-label "PR:Issue-verification-failed"
            gh pr edit $PRNUM --add-label "PR:Ready-to-Review"
          else
            echo "Issue #$issue_num is closed. Please link an open issue to proceed."
            # Add a comment to the PR indicating the issue is not linked correctly.
            gh pr comment $PRNUM --body "PR is  linked to a closed issue. Please link an open issue to proceed."

            # Add the 'Issue-verification-failed' label and remove 'Ready-to-Review'.
            gh pr edit $PRNUM --add-label "PR:Issue-verification-failed"
            gh pr edit $PRNUM --remove-label "PR:Ready-to-Review"
            exit 1
          fi
        else
          echo "Issue not found. Invalid URL or issue number."
          # Add a comment to the PR indicating the issue is not linked correctly.
          gh pr comment $PRNUM --body "PR is not linked to a valid issue. Please update the issue link."
          
          # Apply 'Issue-verification-failed' label and remove 'Ready-to-Review' label.
          gh pr edit $PRNUM --add-label "PR:Issue-verification-failed"
          gh pr edit $PRNUM --remove-label "PR:Ready-to-Review"
          exit 1
        fi
    - name: Check SQL file format and duplicates
      shell: bash
      env: 
          pr_no: ${{ github.event.pull_request.number }}
          GH_TOKEN: ${{ github.token }}
      run: |
        
        # Fetch the latest changes from the main branch
        git fetch origin main

        # Get the list of changed files
        git diff origin/main...HEAD --name-only > diff

        echo "Changed files:"
        cat diff

        echo "Changed SQL files-:"
        # Filter SQL files from the list of changed files
        awk '/scripts\/sql\//' diff

        # Count the number of changed SQL files in the 'scripts/sql' directory
        count=$(awk '/scripts\/sql\//' diff | wc -l)

        # Check if no SQL files were changed
        if [[ $count == "0" ]]; then 
          echo "No SQL files were added, Exiting from this action."
          exit 0
        fi

        # Iterate through each changed SQL file
        for filename in $(awk '/scripts\/sql\//' diff); do
          echo "Checking File: $filename"
          
          # Check if the SQL file name is in the correct format (i.e., it ends with either '.up.sql' or '.down.sql')
          if [[ "$filename" =~ \.(up|down)\.sql$ ]]; then

            # Print a message that the file name is in the correct format
            echo "File name: $filename is in the correct format"
          else
            # Print an error message
            echo "Error: The SQL file name is not in the correct format: $filename."

            # Post a comment on a GitHub pull request with the error message
            gh pr comment $pr_no --body "The SQL file name: $filename is not in the correct format."

            # Exit the script with a non-zero status code
            exit 1 
          fi

          # Navigate to the SQL files directory
          sql_dir="scripts/sql"
          echo "Current directory: $(pwd)"
          cd "$sql_dir"
          echo "SQL files directory: $(pwd)"
          
          # Extract the migration number from the SQL file name
          migration_no=$(echo "$filename" | cut -d "/" -f 3 | cut -d "_" -f 1)
          echo "Migration Number: $migration_no"
          
          # Count the number of files with the same migration number
          migration_files_present_of_this_no=$(ls | cut -d "_" -f 1 | grep -w -c "$migration_no")

          # Navigate back to the original directory
          cd ../..
          
          # Check the conditions based on the number of files with the same migration number
          if [[ $migration_files_present_of_this_no == "2" ]]; then
            echo "All looks good for this migration number."
          elif [[ $migration_files_present_of_this_no == "1" ]]; then
            # Only one file is present for this migration number
            echo "Only single migration file was present for migration no.: $migration_no. either up or down migration is missing! EXITING"
            gh pr comment $pr_no --body "Error: Only a single migration file was present for this number: $migration_no."
            exit 1
          else 
            # Migration number is repeated
            echo "Error: Migration number is repeated."
            gh pr comment $pr_no --body "Error: The SQL file number: $migration_no is duplicated"
            exit 1
          fi
        done

